# Data Modeling & Storage Plan

## Core Database Schema

### Players
- **Purpose**: Store registration records imported from GotSport.
- **Key fields**:
  - `id` (UUID, primary key generated by Supabase)
  - `external_registration_id` (text, unique per GotSport record)
  - `division_id` (UUID → `divisions.id`)
  - `first_name`, `last_name`, `preferred_name`
  - `date_of_birth` (date) and `grade` (text) for eligibility rules
  - `guardian_contacts` (JSONB array with name/email/phone)
  - `mutual_buddy_code` (text) – only honored when a matching code exists
  - `skill_tier` (enum: `novice`, `developing`, `advanced`) – optional balancing input
  - `coach_volunteer` (boolean) and `notes`
- **Indexes & constraints**:
  - Unique constraint on (`division_id`, `external_registration_id`).
  - Partial index on `mutual_buddy_code` where not null for faster lookup.

### Coaches
- **Purpose**: Track adult volunteers and their availability.
- **Key fields**:
  - `id` (UUID)
  - `player_id` (UUID, nullable) linking to their child participant
  - `email`, `phone`, `certifications`
  - `preferred_practice_days` (`day_of_week[]` limited to Mon–Thu)
  - `preferred_practice_window` (tsrange) for time-of-day preferences
  - `can_coach_multiple_teams` (boolean)
  - `status` (`active`, `pending-confirmation`, `inactive`)
- **Indexes & constraints**:
  - Unique index on `email`.
  - Foreign key `player_id` references `players.id` with `ON DELETE SET NULL`.
  - Enum-backed availability days ensure consistent weekday values.

### Divisions
- **Purpose**: Parameterize roster sizing and scheduling per age group.
- **Key fields**:
  - `id` (UUID)
  - `name` (text, e.g., "U10 Girls 7v7")
  - `gender_policy` (enum: `coed`, `girls`, `boys`)
  - `max_roster_size` (smallint)
  - `play_format` (text, e.g., `7v7`)
  - `season_start`, `season_end` (date)
- **Indexes & constraints**:
  - Unique index on `name` per season range to prevent duplicates.

### Teams
- **Purpose**: Persist generated teams and later scheduling assignments.
- **Key fields**:
  - `id` (UUID)
  - `division_id` (UUID)
  - `name` (text)
  - `coach_id` (UUID → `coaches.id`)
  - `assistant_coach_ids` (UUID[])
  - `practice_slot_id` (UUID → `practice_slots.id`, nullable until scheduled)
  - `notes`
- **Indexes & constraints**:
  - Unique (`division_id`, `name`).
  - `assistant_coach_ids` enforced via trigger to ensure referenced coaches exist.

### Team Players
- **Purpose**: Join table assigning players to their teams while tracking assignment provenance.
- **Key fields**:
  - Composite primary key (`team_id`, `player_id`).
  - `role` (text, defaults to `player`) for future assistant roles.
  - `source` (`source_enum`, values `auto` | `manual`) to flag automated vs. manual placements.
  - `added_at` timestamp auto-populated via default expression.
- **Indexes & constraints**:
  - Foreign keys cascade deletes with the parent team or player.
  - `source` limited to expected values via the shared enum for analytics consistency.

### Fields & Locations
- **Purpose**: Represent facilities and discrete playable areas.
- **Tables**:
  - `locations`: `id`, `name`, `address`, `lighting_available`.
  - `fields`: `id`, `location_id`, `name`, `surface_type`, `supports_halves` (boolean).
  - `field_subunits`: optional `id`, `field_id`, `label` (e.g., `A`, `B`) for split fields.

### Time Slots
- **Practice slots** (`practice_slots`):
  - `id`, `field_subunit_id` (nullable → falls back to full field), `day_of_week` (enum Mon–Thu),
    `start_time`, `end_time`, `capacity` (smallint, default 1),
    `valid_from`, `valid_until` for daylight adjustments.
  - Index on (`day_of_week`, `start_time`) for quick lookups.
  - Partial unique indexes prevent double-booking full fields vs. subunits in the same time window.
- **Game slots** (`game_slots`):
  - `id`, `field_id`, `week_index` (smallint), `slot_date`, `start_time`, `end_time`, `division_id` (nullable for shared fields).
  - Unique constraint on (`field_id`, `slot_date`, `start_time`).

### Schedules
- **Practice assignments** (`practice_assignments`):
  - `id`, `team_id`, `practice_slot_id`, `effective_date_range` (`daterange`), `source` (`source_enum`: `auto` | `manual`).
  - Unique constraint on (`team_id`, `practice_slot_id`, `effective_date_range`) with a check preventing empty ranges.
- **Game assignments** (`games`):
  - `id`, `home_team_id`, `away_team_id`, `game_slot_id`, `week_index`, `score_home`, `score_away`.
  - Constraints enforcing teams belong to same division, differ from each other, and use compatible `game_slots`.

### Configuration & Metadata
- `season_settings`: Single-row table for league-wide parameters (roster formulas, daylight change dates, export templates).
- `import_jobs`: Tracks CSV uploads with status, source file references (Supabase Storage path), error logs, and user id.

### Scheduler Run History
- `team_generation_runs`: Persists each roster generation attempt with JSON parameters, aggregated metrics (e.g., players per team, buddy success rates), and timestamps so admins can compare multiple passes.
- `practice_scheduler_runs` / `game_scheduler_runs`: Mirror structure of team generation runs while capturing conflict summaries and fairness metrics per execution. These tables support dashboards showing automation success vs. manual follow-up workload.

### Evaluation & Remediation Tables
- `evaluation_runs`: Stores evaluation pipeline executions linked to the originating scheduler run (`team`, `practice`, `game`, or `composite`). Includes status, severity flags, metrics snapshots, and auto-fix summaries.
- `evaluation_findings`: Row-per-issue log with severity, machine-friendly `finding_code`, and affected entity metadata so the UI can group results by team or field.
- `evaluation_metrics`: Key/value metric store with optional thresholds for fairness scoring; unique per evaluation/metric pair to prevent duplicates.
- `evaluation_run_events`: Timeline of remediation actions (auto fixes, manual overrides, notes) tied to an evaluation run for auditability.

### Export & Communication Logging
- `export_jobs`: Background job tracker for generating master and team-specific schedule files. Captures payload filters, schema version, storage paths, and error details for retriable failures.
- `email_log`: Minimal audit table recording when coach communication drafts are generated, copied, or sent (if an email API is later integrated), referencing the originating `export_job` when available.

## Data Ingestion Utilities
Detailed ingestion workflows live in `docs/ingestion-pipeline.md`. Highlights below summarize the responsibilities that inform the database design.

1. **Registration Importer**
   - Parses GotSport CSV exports.
   - Normalizes guardian contact information into structured JSON.
   - Validates mutual buddy codes by checking for reciprocal entries before linking pairs.
   - Flags duplicate registrations or missing division assignments for manual review.
2. **Field Availability Importer**
   - Accepts standardized CSV with `location,field,subunit,day,start,end,type,capacity,valid_until` columns.
   - Creates or updates `locations`, `fields`, `field_subunits`, and corresponding slot records.
   - Applies daylight change windows by splitting rows where `valid_until` precedes season end.
3. **Manual Admin Tools**
   - Provide UI forms to edit or append players, coaches, and slots.
   - Audit log each change in `import_jobs` with source `manual` for traceability.

## Seeding & Test Data Strategy
- Maintain `/supabase/seed` SQL files to insert representative divisions, players, coaches, and slots for local testing.
- Include buddy pairs, multi-team coaches, and varying capacities to exercise scheduling logic.
- Provide a ready-to-run dataset in `docs/sql/sample_seed_data.sql` that provisions a Fall 2024 recreation season with two divisions, seeded facilities, practice/game slots, teams, players, and example assignments.  The script is idempotent so it can refresh local Supabase instances repeatedly via `psql`.
- Automate resets with an npm script invoking `supabase db reset` pointing to a disposable local stack.
- Document seed assumptions so QA can validate schedule outputs against expected scenarios.

## Initial Schema Draft
- The first-pass DDL for these entities lives in `docs/sql/initial_schema.sql`. It can be copied into a Supabase migration
  once validated locally. The script establishes core tables, lookup constraints, helper staging tables, scheduler run histories,
  evaluation artifacts, export trackers, and supporting indexes required for ingestion, team assignments, scheduling, and
  downstream reporting. Shared timestamp triggers keep `updated_at` fresh across mutable tables.
- Follow-up work includes adding Row Level Security policies and additional data quality constraints (e.g., enforcing assistant
  coach references) before promoting the script to production migrations.

## Data Governance Considerations
- Enable Row Level Security on all tables with policy breakdowns captured in `docs/rls-policies.md`.  Admin personas receive full access while future coach-facing views are limited to roster visibility with masked guardian contact data.
- Store personally identifiable information (PII) only as required; redact optional fields from exports when not necessary.
- Regularly archive prior seasons by copying data into `season_history` tables or Supabase Storage exports to stay within free-tier quotas.
- Monitor Supabase storage for uploaded CSVs and purge older imports after verification.
