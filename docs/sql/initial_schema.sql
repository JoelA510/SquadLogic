-- Initial schema draft for youth sports scheduler
-- This file translates the data modeling plan into concrete SQL DDL
-- statements suitable for a Supabase/Postgres migration.  It focuses on
-- core entities required for registration intake, team formation, and
-- scheduling.  RLS policies will be defined in subsequent migrations.

begin;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'day_of_week') then
        create type day_of_week as enum ('mon','tue','wed','thu','fri','sat','sun');
    end if;
end$$;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'source_enum') then
        create type source_enum as enum ('auto','manual');
    end if;
end$$;

create or replace function trigger_set_timestamp()
returns trigger
language plpgsql
set search_path = public
as $$
begin
    new.updated_at = timezone('utc', now());
    return new;
end;
$$;

create table if not exists season_settings (
    id            bigint generated by default as identity primary key,
    season_label  text        not null,
    season_year   integer     not null,
    season_start  date        not null,
    season_end    date        not null,
    roster_formula jsonb      not null default '{}'::jsonb,
    daylight_adjustments jsonb not null default '[]'::jsonb,
    exports_config jsonb      not null default '{}'::jsonb,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    unique (season_label, season_year)
);

create table if not exists divisions (
    id              uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    name            text not null,
    gender_policy   text check (gender_policy in ('coed', 'girls', 'boys')) default 'coed',
    max_roster_size smallint not null,
    play_format     text not null,
    season_start    date not null,
    season_end      date not null,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (season_settings_id, name)
);

create table if not exists players (
    id                        uuid primary key default gen_random_uuid(),
    division_id               uuid not null references divisions(id) on delete cascade,
    external_registration_id  text not null,
    first_name                text not null,
    last_name                 text not null,
    preferred_name            text,
    date_of_birth             date,
    grade                     text,
    guardian_contacts         jsonb not null default '[]'::jsonb,
    mutual_buddy_code         text,
    skill_tier                text check (skill_tier in ('novice', 'developing', 'advanced')),
    coach_volunteer           boolean not null default false,
    notes                     text,
    created_at                timestamptz not null default timezone('utc', now()),
    updated_at                timestamptz not null default timezone('utc', now()),
    unique (division_id, external_registration_id)
);

create index if not exists players_mutual_buddy_code_idx
    on players (mutual_buddy_code)
    where mutual_buddy_code is not null;

create table if not exists coaches (
    id                           uuid primary key default gen_random_uuid(),
    player_id                    uuid references players(id) on delete set null,
    full_name                    text not null,
    email                        text not null,
    phone                        text,
    certifications               text,
    preferred_practice_days      day_of_week[] check (preferred_practice_days <@ array['mon','tue','wed','thu']::day_of_week[]),
    preferred_practice_window    tsrange,
    can_coach_multiple_teams     boolean not null default false,
    status                       text not null default 'active' check (status in ('active', 'pending-confirmation', 'inactive')),
    created_at                   timestamptz not null default timezone('utc', now()),
    updated_at                   timestamptz not null default timezone('utc', now()),
    unique (email)
);

create table if not exists locations (
    id                  uuid primary key default gen_random_uuid(),
    name                text not null,
    address             text,
    lighting_available  boolean not null default false,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (name)
);

create table if not exists fields (
    id              uuid primary key default gen_random_uuid(),
    location_id     uuid not null references locations(id) on delete cascade,
    name            text not null,
    surface_type    text,
    supports_halves boolean not null default false,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (location_id, name)
);

create table if not exists field_subunits (
    id         uuid primary key default gen_random_uuid(),
    field_id   uuid not null references fields(id) on delete cascade,
    label      text not null,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique (field_id, label)
);

create table if not exists practice_slots (
    id                uuid primary key default gen_random_uuid(),
    field_id          uuid not null references fields(id) on delete cascade,
    field_subunit_id  uuid references field_subunits(id) on delete cascade,
    day_of_week       day_of_week not null check (day_of_week in ('mon','tue','wed','thu')),
    start_time        time not null,
    end_time          time not null,
    capacity          smallint not null default 1,
    valid_from        date not null,
    valid_until       date not null,
    created_at        timestamptz not null default timezone('utc', now()),
    updated_at        timestamptz not null default timezone('utc', now()),
    constraint practice_slots_time_check check (end_time > start_time)
);

create index if not exists practice_slots_lookup_idx
    on practice_slots (day_of_week, start_time);

create unique index if not exists practice_slots_subunit_unique_idx
    on practice_slots (field_subunit_id, day_of_week, start_time, valid_from)
    where field_subunit_id is not null;

create unique index if not exists practice_slots_field_unique_idx
    on practice_slots (field_id, day_of_week, start_time, valid_from)
    where field_subunit_id is null;

create table if not exists game_slots (
    id            uuid primary key default gen_random_uuid(),
    field_id      uuid not null references fields(id) on delete cascade,
    division_id   uuid references divisions(id) on delete set null,
    slot_date     date not null,
    start_time    time not null,
    end_time      time not null,
    week_index    smallint,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    constraint game_slots_time_check check (end_time > start_time),
    unique (field_id, slot_date, start_time)
);

create table if not exists teams (
    id                   uuid primary key default gen_random_uuid(),
    division_id          uuid not null references divisions(id) on delete cascade,
    name                 text not null,
    coach_id             uuid references coaches(id) on delete set null,
    assistant_coach_ids  uuid[] default '{}'::uuid[],
    practice_slot_id     uuid references practice_slots(id) on delete set null,
    notes                text,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    unique (division_id, name)
);

create table if not exists team_players (
    team_id   uuid not null references teams(id) on delete cascade,
    player_id uuid not null references players(id) on delete cascade,
    role      text not null default 'player',
    source    source_enum not null default 'auto'::source_enum,
    added_at  timestamptz not null default timezone('utc', now()),
    primary key (team_id, player_id)
);

create table if not exists practice_assignments (
    id                  uuid primary key default gen_random_uuid(),
    team_id             uuid not null references teams(id) on delete cascade,
    practice_slot_id    uuid not null references practice_slots(id) on delete cascade,
    effective_date_range daterange not null,
    source              source_enum not null default 'auto'::source_enum,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    constraint practice_assignments_effective_date_range_not_empty check (not isempty(effective_date_range)),
    unique (team_id, practice_slot_id, effective_date_range)
);

create table if not exists games (
    id              uuid primary key default gen_random_uuid(),
    game_slot_id    uuid not null references game_slots(id) on delete cascade,
    home_team_id    uuid not null references teams(id) on delete cascade,
    away_team_id    uuid not null references teams(id) on delete cascade,
    week_index      smallint,
    score_home      smallint,
    score_away      smallint,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    constraint games_team_difference check (home_team_id <> away_team_id)
);

create or replace function ensure_assistant_coach_ids_valid()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    duplicates uuid[];
    missing_coaches uuid[];
begin
    if new.assistant_coach_ids is null or cardinality(new.assistant_coach_ids) = 0 then
        return new;
    end if;

    if array_position(new.assistant_coach_ids, null) is not null then
        raise exception 'assistant_coach_ids cannot contain null values';
    end if;

    select array_agg(coach_id)
      into duplicates
    from (
        select coach_id
        from unnest(new.assistant_coach_ids) as coach_id
        group by coach_id
        having count(*) > 1
    ) dup;

    if duplicates is not null then
        raise exception 'assistant_coach_ids contains duplicate values: %', duplicates;
    end if;

    if new.coach_id is not null and new.coach_id = any(new.assistant_coach_ids) then
        raise exception 'Head coach % cannot also be listed as an assistant', new.coach_id;
    end if;

    select array_agg(u.coach_id)
      into missing_coaches
    from unnest(new.assistant_coach_ids) as u(coach_id)
    left join coaches c on c.id = u.coach_id
    where c.id is null;

    if missing_coaches is not null then
        raise exception 'assistant_coach_ids references coaches that do not exist: %', missing_coaches;
    end if;

    return new;
end;
$$;

create or replace function ensure_game_team_consistency()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    home_division uuid;
    away_division uuid;
begin
    select division_id into home_division from teams where id = new.home_team_id;
    if home_division is null then
        raise exception 'Home team % does not exist', new.home_team_id;
    end if;

    select division_id into away_division from teams where id = new.away_team_id;
    if away_division is null then
        raise exception 'Away team % does not exist', new.away_team_id;
    end if;

    if home_division <> away_division then
        raise exception 'Teams % and % belong to different divisions', new.home_team_id, new.away_team_id;
    end if;

    if new.game_slot_id is not null then
        perform 1
        from game_slots gs
        where gs.id = new.game_slot_id
          and (gs.division_id is null or gs.division_id = home_division);

        if not found then
            raise exception 'Game slot % is not compatible with division %', new.game_slot_id, home_division;
        end if;
    end if;

    return new;
end;
$$;

drop trigger if exists set_timestamp_season_settings on season_settings;
create trigger set_timestamp_season_settings
    before update on season_settings
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_divisions on divisions;
create trigger set_timestamp_divisions
    before update on divisions
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_players on players;
create trigger set_timestamp_players
    before update on players
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_coaches on coaches;
create trigger set_timestamp_coaches
    before update on coaches
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_locations on locations;
create trigger set_timestamp_locations
    before update on locations
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_fields on fields;
create trigger set_timestamp_fields
    before update on fields
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_field_subunits on field_subunits;
create trigger set_timestamp_field_subunits
    before update on field_subunits
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_practice_slots on practice_slots;
create trigger set_timestamp_practice_slots
    before update on practice_slots
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_game_slots on game_slots;
create trigger set_timestamp_game_slots
    before update on game_slots
    for each row execute function trigger_set_timestamp();

drop trigger if exists ensure_teams_assistant_coaches_valid on teams;
create trigger ensure_teams_assistant_coaches_valid
    before insert or update on teams
    for each row execute function ensure_assistant_coach_ids_valid();

drop trigger if exists set_timestamp_teams on teams;
create trigger set_timestamp_teams
    before update on teams
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_practice_assignments on practice_assignments;
create trigger set_timestamp_practice_assignments
    before update on practice_assignments
    for each row execute function trigger_set_timestamp();

drop trigger if exists ensure_games_valid on games;
create trigger ensure_games_valid
    before insert or update on games
    for each row execute function ensure_game_team_consistency();

drop trigger if exists set_timestamp_games on games;
create trigger set_timestamp_games
    before update on games
    for each row execute function trigger_set_timestamp();

create table if not exists import_jobs (
    id                 uuid primary key default gen_random_uuid(),
    job_type           text not null check (job_type in ('registration','fields','manual')),
    storage_path       text not null,
    status             text not null check (status in ('queued','processing','completed','completed_with_warnings','needs_fix')),
    started_at         timestamptz default timezone('utc', now()),
    completed_at       timestamptz,
    total_rows         integer,
    processed_rows     integer,
    error_summary      jsonb default '{}'::jsonb,
    warning_summary    jsonb default '{}'::jsonb,
    created_by         uuid,
    created_at         timestamptz not null default timezone('utc', now())
);

create table if not exists staging_players (
    id                    bigint generated by default as identity primary key,
    import_job_id         uuid not null references import_jobs(id) on delete cascade,
    raw_payload           jsonb not null,
    normalized_payload    jsonb,
    validation_errors     jsonb default '[]'::jsonb,
    validation_warnings   jsonb default '[]'::jsonb,
    processed_at          timestamptz,
    created_at            timestamptz not null default timezone('utc', now())
);

create table if not exists player_buddies (
    player_id        uuid not null references players(id) on delete cascade,
    buddy_player_id  uuid not null references players(id) on delete cascade,
    source_import_job uuid not null references import_jobs(id) on delete cascade,
    is_mutual        boolean not null default false,
    created_at       timestamptz not null default timezone('utc', now()),
    primary key (player_id, buddy_player_id),
    constraint player_buddies_player_ne_buddy check (player_id <> buddy_player_id)
);

commit;
