-- Initial schema draft for youth sports scheduler
-- This file translates the data modeling plan into concrete SQL DDL
-- statements suitable for a Supabase/Postgres migration.  It focuses on
-- core entities required for registration intake, team formation, and
-- scheduling.  RLS policies will be defined in subsequent migrations.

begin;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'day_of_week') then
        create type day_of_week as enum ('mon','tue','wed','thu','fri','sat','sun');
    end if;
end$$;

create or replace function trigger_set_timestamp()
returns trigger
language plpgsql
set search_path = public
as $$
begin
    new.updated_at = timezone('utc', now());
    return new;
end;
$$;

create table if not exists season_settings (
    id            bigint generated by default as identity primary key,
    season_label  text        not null,
    season_year   integer     not null,
    season_start  date        not null,
    season_end    date        not null,
    roster_formula jsonb      not null default '{}'::jsonb,
    daylight_adjustments jsonb not null default '[]'::jsonb,
    exports_config jsonb      not null default '{}'::jsonb,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    unique (season_label, season_year)
);

create table if not exists divisions (
    id              uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    name            text not null,
    gender_policy   text check (gender_policy in ('coed', 'girls', 'boys')) default 'coed',
    max_roster_size smallint not null,
    play_format     text not null,
    season_start    date not null,
    season_end      date not null,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (season_settings_id, name)
);

create table if not exists players (
    id                        uuid primary key default gen_random_uuid(),
    division_id               uuid not null references divisions(id) on delete cascade,
    external_registration_id  text not null,
    first_name                text not null,
    last_name                 text not null,
    preferred_name            text,
    date_of_birth             date,
    grade                     text,
    guardian_contacts         jsonb not null default '[]'::jsonb,
    mutual_buddy_code         text,
    skill_tier                text check (skill_tier in ('novice', 'developing', 'advanced')),
    coach_volunteer           boolean not null default false,
    notes                     text,
    created_at                timestamptz not null default timezone('utc', now()),
    updated_at                timestamptz not null default timezone('utc', now()),
    unique (division_id, external_registration_id)
);

create index if not exists players_mutual_buddy_code_idx
    on players (mutual_buddy_code)
    where mutual_buddy_code is not null;

create table if not exists coaches (
    id                           uuid primary key default gen_random_uuid(),
    player_id                    uuid references players(id) on delete set null,
    full_name                    text not null,
    email                        text not null,
    phone                        text,
    certifications               text,
    preferred_practice_days      day_of_week[] check (preferred_practice_days <@ array['mon','tue','wed','thu']::day_of_week[]),
    preferred_practice_window    tsrange,
    can_coach_multiple_teams     boolean not null default false,
    status                       text not null default 'active' check (status in ('active', 'pending-confirmation', 'inactive')),
    created_at                   timestamptz not null default timezone('utc', now()),
    updated_at                   timestamptz not null default timezone('utc', now()),
    unique (email)
);

create table if not exists locations (
    id                  uuid primary key default gen_random_uuid(),
    name                text not null,
    address             text,
    lighting_available  boolean not null default false,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (name)
);

create table if not exists fields (
    id              uuid primary key default gen_random_uuid(),
    location_id     uuid not null references locations(id) on delete cascade,
    name            text not null,
    surface_type    text,
    supports_halves boolean not null default false,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (location_id, name)
);

create table if not exists field_subunits (
    id         uuid primary key default gen_random_uuid(),
    field_id   uuid not null references fields(id) on delete cascade,
    label      text not null,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique (field_id, label)
);

create table if not exists practice_slots (
    id                uuid primary key default gen_random_uuid(),
    field_id          uuid not null references fields(id) on delete cascade,
    field_subunit_id  uuid references field_subunits(id) on delete cascade,
    day_of_week       day_of_week not null check (day_of_week in ('mon','tue','wed','thu')),
    start_time        time not null,
    end_time          time not null,
    capacity          smallint not null default 1,
    valid_from        date not null,
    valid_until       date not null,
    created_at        timestamptz not null default timezone('utc', now()),
    updated_at        timestamptz not null default timezone('utc', now()),
    constraint practice_slots_time_check check (end_time > start_time)
);

create index if not exists practice_slots_lookup_idx
    on practice_slots (day_of_week, start_time);

create unique index if not exists practice_slots_subunit_unique_idx
    on practice_slots (field_subunit_id, day_of_week, start_time, valid_from)
    where field_subunit_id is not null;

create unique index if not exists practice_slots_field_unique_idx
    on practice_slots (field_id, day_of_week, start_time, valid_from)
    where field_subunit_id is null;

create table if not exists game_slots (
    id            uuid primary key default gen_random_uuid(),
    field_id      uuid not null references fields(id) on delete cascade,
    division_id   uuid references divisions(id) on delete set null,
    slot_date     date not null,
    start_time    time not null,
    end_time      time not null,
    week_index    smallint,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    constraint game_slots_time_check check (end_time > start_time),
    unique (field_id, slot_date, start_time)
);

create table if not exists teams (
    id                   uuid primary key default gen_random_uuid(),
    division_id          uuid not null references divisions(id) on delete cascade,
    name                 text not null,
    coach_id             uuid references coaches(id) on delete set null,
    assistant_coach_ids  uuid[] default '{}',
    practice_slot_id     uuid references practice_slots(id) on delete set null,
    notes                text,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    unique (division_id, name)
);

create table if not exists team_players (
    team_id   uuid not null references teams(id) on delete cascade,
    player_id uuid not null references players(id) on delete cascade,
    role      text not null default 'player',
    added_at  timestamptz not null default timezone('utc', now()),
    primary key (team_id, player_id)
);

create table if not exists practice_assignments (
    id                  uuid primary key default gen_random_uuid(),
    team_id             uuid not null references teams(id) on delete cascade,
    practice_slot_id    uuid not null references practice_slots(id) on delete cascade,
    effective_range     daterange not null,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (team_id, practice_slot_id, effective_range)
);

create table if not exists games (
    id              uuid primary key default gen_random_uuid(),
    game_slot_id    uuid not null references game_slots(id) on delete cascade,
    home_team_id    uuid not null references teams(id) on delete cascade,
    away_team_id    uuid not null references teams(id) on delete cascade,
    week_index      smallint,
    score_home      smallint,
    score_away      smallint,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    constraint games_team_difference check (home_team_id <> away_team_id)
);

drop trigger if exists set_timestamp_season_settings on season_settings;
create trigger set_timestamp_season_settings
    before update on season_settings
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_divisions on divisions;
create trigger set_timestamp_divisions
    before update on divisions
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_players on players;
create trigger set_timestamp_players
    before update on players
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_coaches on coaches;
create trigger set_timestamp_coaches
    before update on coaches
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_locations on locations;
create trigger set_timestamp_locations
    before update on locations
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_fields on fields;
create trigger set_timestamp_fields
    before update on fields
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_field_subunits on field_subunits;
create trigger set_timestamp_field_subunits
    before update on field_subunits
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_practice_slots on practice_slots;
create trigger set_timestamp_practice_slots
    before update on practice_slots
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_game_slots on game_slots;
create trigger set_timestamp_game_slots
    before update on game_slots
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_teams on teams;
create trigger set_timestamp_teams
    before update on teams
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_practice_assignments on practice_assignments;
create trigger set_timestamp_practice_assignments
    before update on practice_assignments
    for each row execute function trigger_set_timestamp();

drop trigger if exists set_timestamp_games on games;
create trigger set_timestamp_games
    before update on games
    for each row execute function trigger_set_timestamp();

create table if not exists import_jobs (
    id                 uuid primary key default gen_random_uuid(),
    job_type           text not null check (job_type in ('registration','fields','manual')),
    storage_path       text not null,
    status             text not null check (status in ('queued','processing','completed','completed_with_warnings','needs_fix')),
    started_at         timestamptz default timezone('utc', now()),
    completed_at       timestamptz,
    total_rows         integer,
    processed_rows     integer,
    error_summary      jsonb default '{}'::jsonb,
    warning_summary    jsonb default '{}'::jsonb,
    created_by         uuid,
    created_at         timestamptz not null default timezone('utc', now())
);

create table if not exists staging_players (
    id                    bigint generated by default as identity primary key,
    import_job_id         uuid not null references import_jobs(id) on delete cascade,
    raw_payload           jsonb not null,
    normalized_payload    jsonb,
    validation_errors     jsonb default '[]'::jsonb,
    validation_warnings   jsonb default '[]'::jsonb,
    processed_at          timestamptz,
    created_at            timestamptz not null default timezone('utc', now())
);

create table if not exists player_buddies (
    player_id        uuid not null references players(id) on delete cascade,
    buddy_player_id  uuid not null references players(id) on delete cascade,
    source_import_job uuid not null references import_jobs(id) on delete cascade,
    is_mutual        boolean not null default false,
    created_at       timestamptz not null default timezone('utc', now()),
    primary key (player_id, buddy_player_id),
    constraint player_buddies_player_ne_buddy check (player_id <> buddy_player_id)
);

commit;
