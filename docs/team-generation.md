# Team Generation Design

This document translates the roadmap's team formation phase into actionable plans for the GotSport Teamer Scheduler. It assumes the data model described in `docs/data-modeling.md` and focuses on how to transform cleaned registration data into balanced rosters that honor mutual buddy requests and coach commitments.

## Objectives
- Produce balanced teams per division that respect maximum roster sizes stored in the database.
- Keep mutually confirmed buddies together while ignoring one-sided requests.
- Guarantee that each volunteer head coach is paired with their player(s).
- Surface enough metadata so admins can audit fairness and make manual swaps before schedules are generated.

## Inputs
- **Players**: Retrieved from the `players` table, joined with `divisions` to determine roster caps and gameplay formats.
- **Buddy pairs**: Derived from `players.mutual_buddy_code`. Only reciprocal matches are considered valid.
- **Coach volunteers**: From the `coaches` table with `player_id` links and `can_coach_multiple_teams` flag.
- **Configuration**: Season-level overrides from `season_settings` (roster adjustments, division ordering, lock dates).

## Processing Steps
1. **Division preparation**
   - Query all active divisions for the upcoming season along with `max_roster_size`, ordering by youngest divisions first (customizable via `season_settings`).
   - Fetch players per division, grouping by grade or skill tier when present.
   - Build "assignment units" that either represent a single player or a confirmed buddy pair.
2. **Coach anchoring**
   - For each unit containing a coach's child, pre-assign a team shell and attach the coach profile.
   - Support coaches with multiple teams by reading `can_coach_multiple_teams`; create one slot per team request.
3. **Roster balancing algorithm**
   - Determine required team count as `ceil(totalPlayers / maxRosterSize)` while ensuring enough slots for coach commitments.
   - Initialize team objects with metadata: division, coach (if already placed), assistant capacity, and roster limit.
   - Iterate through shuffled assignment units, always placing the next unit into the team with the smallest roster load. Use a tie-breaker that favors teams lacking coaches to keep leadership balanced.
   - If adding a unit would exceed the roster cap, place it in an overflow queue for manual resolution.
4. **Skill or experience balancing** (optional phase)
   - When `players.skill_tier` exists, perform a serpentine draft per tier to distribute skill evenly before filling remaining slots randomly.
5. **Fairness metrics & diagnostics**
   - After allocation, compute per-team roster counts, number of buddy pairs, and presence of volunteer coaches.
   - Log unmatched buddy requests, overflow players, and divisions that exceed configured roster caps.
   - Store diagnostics in a `scheduler_runs` entry (`run_type = 'team'`) for audit history (future enhancement).

## Outputs
- **Teams table updates**: Insert or upsert team records with `division_id`, autogenerated `name`, assigned `coach_id`, and notes about buddy pairs.
- **Roster assignments**: Populate a join table `team_players` with each player's `team_id`, assignment timestamp, and source (`auto` vs `manual`).
- **Buddy resolution report**: JSON payload summarizing honored and unmet buddy requests for admin review.
- **Coach coverage summary**: Highlight any division lacking enough volunteer coaches to meet team counts.

## Manual Adjustment Workflow
1. Present team rosters in the admin UI with sortable columns (player name, buddy code, skill tier).
2. Allow drag-and-drop or action buttons to swap players across teams, updating `team_players` and logging adjustments.
3. Provide quick filters for overflow units so admins can resolve outstanding assignments before locking rosters.
4. Once approved, mark the run as `finalized` to prevent automated reshuffles without explicit reset.

## Quality Checks
- **Data validation**: Ensure each player appears on exactly one team (or flagged as overflow). Enforce database constraints to prevent duplicates.
- **Coach-child linkage**: Verify that every `coaches.player_id` has a corresponding roster entry on the coach's team.
- **Buddy integrity**: Confirm that buddy pairs share the same `team_id`; emit warnings when roster caps prevent pairing.
- **Audit trail**: Record the algorithm version and input snapshot so future reruns can be compared for consistency.

## Integration Points
- Expose a serverless function (e.g., `/api/team-generation/run`) that triggers the workflow and writes results to Supabase.
- Use Supabase Realtime or polling to update the UI with progress states (`queued`, `running`, `completed`, `needs_manual_action`).
- Gate reruns behind an admin confirmation to avoid overwriting manual adjustments without exporting a diff.

## Acceptance Criteria & Test Harness Outline
- **Happy path**: For each division, all players (including buddy pairs) are assigned without exceeding roster caps when enough capacity exists.
- **Coach coverage**: Every coach volunteer with `can_coach_multiple_teams = false` is assigned to exactly one roster that includes their player.
- **Buddy enforcement**: Mutual buddy requests always share a `team_id`; single-sided or invalid codes are reported but do not block assignment.
- **Overflow handling**: When roster caps are insufficient, affected players are surfaced in an overflow report with division context.
- **Diagnostics**: Algorithm emits a structured summary (team counts, buddy stats, overflow list) persisted to `scheduler_runs`.

### Test harness plan
- Use Jest with a fixture loader that seeds in-memory objects mirroring the schema (players, coaches, divisions, configuration).
- Provide scenario fixtures: balanced division, buddy-heavy division, coach overlap division, and capacity-deficit division.
- Assert both database mutations (mocked repositories) and diagnostic payload content for each scenario.
- Integrate snapshot tests for the overflow report and buddy resolution report to detect regressions in admin-facing outputs.

## Next Steps
- Implement Jest unit tests for buddy pairing logic, roster balancing, and overflow detection using the seed data proposed in the data modeling plan.
- Design admin UI wireframes for the roster review page, including filters and manual adjustment controls.
- Draft Supabase Row Level Security policies limiting roster edits to authenticated admin roles.
