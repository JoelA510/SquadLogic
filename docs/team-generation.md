# Team Generation Design

This document translates the roadmap's team formation phase into actionable plans for the GotSport Teamer Scheduler. It assumes the data model described in `docs/data-modeling.md` and focuses on how to transform cleaned registration data into balanced rosters that honor mutual buddy requests and coach commitments.

## Objectives
- Produce balanced teams per division that respect maximum roster sizes stored in the database.
- Keep mutually confirmed buddies together while ignoring one-sided requests.
- Guarantee that each volunteer head coach is paired with their player(s).
- Surface enough metadata so admins can audit fairness and make manual swaps before schedules are generated.

## Inputs
- **Players**: Retrieved from the `players` table, joined with `divisions` to determine roster caps and gameplay formats.
- **Buddy pairs**: Derived from `players.mutual_buddy_code`. Only reciprocal matches are considered valid.
- **Coach volunteers**: From the `coaches` table with `player_id` links and `can_coach_multiple_teams` flag.
- **Configuration**: Season-level overrides from `season_settings` (roster adjustments, division ordering, lock dates).

## Processing Steps
1. **Division preparation**
   - Query all active divisions for the upcoming season along with `max_roster_size`, ordering by youngest divisions first (customizable via `season_settings`).
   - Fetch players per division, grouping by grade or skill tier when present.
   - Build "assignment units" that either represent a single player or a confirmed buddy pair.
2. **Coach anchoring**
   - For each unit containing a coach's child, pre-assign a team shell and attach the coach profile.
   - Support coaches with multiple teams by reading `can_coach_multiple_teams`; create one slot per team request.
3. **Roster balancing algorithm**
   - Determine required team count as `ceil(totalPlayers / maxRosterSize)` while ensuring enough slots for coach commitments.
   - Initialize team objects with metadata: division, coach (if already placed), assistant capacity, and roster limit.
   - Iterate through shuffled assignment units, always placing the next unit into the team with the smallest roster load. Use a tie-breaker that favors teams lacking coaches to keep leadership balanced.
   - If adding a unit would exceed the roster cap, place it in an overflow queue for manual resolution.
4. **Skill or experience balancing** (optional phase)
   - When `players.skill_tier` exists, perform a serpentine draft per tier to distribute skill evenly before filling remaining slots randomly.
5. **Fairness metrics & diagnostics**
   - After allocation, compute per-team roster counts, number of buddy pairs, and presence of volunteer coaches.
   - Log unmatched buddy requests, overflow players, and divisions that exceed configured roster caps.
   - Store diagnostics in a `scheduler_runs` entry (`run_type = 'team'`) for audit history (future enhancement).

## Outputs
- **Teams table updates**: Insert or upsert team records with `division_id`, autogenerated `name`, assigned `coach_id`, and notes about buddy pairs. The allocator now supports per-division naming controls: provide `teamNames` to supply explicit names in order or `teamNamePrefix` to generate labeled defaults (e.g., `Lightning 01`, `Lightning 02`) before falling back to `"{division} Team {index}"`.
- **Roster assignments**: Populate a join table `team_players` with each player's `team_id`, assignment timestamp, and source (`auto` vs `manual`).
- **Overflow queue**: The allocator exposes an `overflowByDivision` collection so manual workflows can immediately review units that exceeded roster capacity.
- **Buddy resolution report**: JSON payload summarizing honored and unmet buddy requests for admin review. The allocator now exposes this via `buddyDiagnosticsByDivision`, listing mutual pairs alongside unmatched requests (missing registrations, non-reciprocal entries, and self references) so admins can reconcile data issues quickly.
- **Coach coverage summary**: Highlight any division lacking enough volunteer coaches to meet team counts. The allocator now
  returns this metadata through `coachCoverageByDivision`, which includes total team counts, volunteer coach coverage, and a
  `needsAdditionalCoaches` flag so the admin workflow can prioritize outreach.
- **Persistence snapshot builder**: The new `prepareTeamPersistenceSnapshot` helper in `src/teamPersistenceSnapshot.js`
  packages the Supabase payloads (team rows plus player rows) alongside admin-facing metadata such as manual override queues,
  pending/applied counts, and run history ordering. The helper also normalizes manual overrides (defaulting status to
  `pending`, enforcing known status values, and filling in team names from the normalized Supabase payloads) while returning
  the prepared counts that the admin dashboard displays. Only overrides explicitly marked as `applied` are folded into the
  Supabase-ready team rows; pending or unspecified statuses remain in the admin queue metadata so the dashboard can surface
  them for review without mutating persistence payloads. This gives the dashboard enough context to display readiness without
  reimplementing normalization logic on the client.
- **Admin shell persistence trigger**: The dashboard now posts override-ready payloads to a configurable
  `VITE_SUPABASE_PERSISTENCE_URL` endpoint when present (via `teamPersistenceClient.js`), retaining the local simulator as a
  fallback. When only a `SUPABASE_URL` (or `VITE_SUPABASE_URL`) is provided, the client now derives the Edge Function base
  (`<supabase-url>/functions/v1`) automatically so deployments that export Supabase URLs to the frontend no longer need a
  separate `VITE_SUPABASE_PERSISTENCE_URL`. Pending manual overrides still block push attempts client-side so the UI avoids
  unnecessary network calls when the Supabase run would be rejected. When a live endpoint is configured, the UI now surfaces
  which host will be called and echoes backend-provided error messages so admins can distinguish client validation failures
  from server-side rejections.
- **Server-side request processor**: `processTeamPersistenceRequest` (see `src/teamPersistenceApi.js`) centralizes auth checks,
  snapshot validation, and transactional upserts so Edge Functions or Node handlers can reuse the same path as the dashboard.
  This keeps server responses consistent with the client simulator while ensuring `scheduler_runs` and roster tables stay in
  sync.
- **Supabase Edge Function**: `supabase/functions/team-persistence/index.ts` wraps the HTTP handler for deployment, using
  `TEAM_PERSISTENCE_ALLOWED_ROLES` (fallback: `admin`, `scheduler`) to align backend role checks with the dashboardâ€™s
  expectations.

## Manual Adjustment Workflow
1. Present team rosters in the admin UI with sortable columns (player name, buddy code, skill tier).
2. Allow drag-and-drop or action buttons to swap players across teams, updating `team_players` and logging adjustments.
3. Provide quick filters for overflow units so admins can resolve outstanding assignments before locking rosters.
4. Once approved, mark the run as `finalized` to prevent automated reshuffles without explicit reset.

## Quality Checks
- **Data validation**: Ensure each player appears on exactly one team (or flagged as overflow). Enforce database constraints to prevent duplicates.
- **Coach-child linkage**: Verify that every `coaches.player_id` has a corresponding roster entry on the coach's team.
- **Buddy integrity**: Confirm that buddy pairs share the same `team_id`; emit warnings when roster caps prevent pairing.
- **Audit trail**: Record the algorithm version and input snapshot so future reruns can be compared for consistency.

## Integration Points
- Expose a serverless function (e.g., `/api/team-generation/run`) that triggers the workflow and writes results to Supabase.
- Use Supabase Realtime or polling to update the UI with progress states (`queued`, `running`, `completed`, `needs_manual_action`).
- Gate reruns behind an admin confirmation to avoid overwriting manual adjustments without exporting a diff.

## Acceptance Criteria & Test Harness Outline
- **Happy path**: For each division, all players (including buddy pairs) are assigned without exceeding roster caps when enough capacity exists.
- **Coach coverage**: Every coach volunteer with `can_coach_multiple_teams = false` is assigned to exactly one roster that includes their player.
- **Buddy enforcement**: Mutual buddy requests always share a `team_id`; single-sided or invalid codes are reported but do not block assignment.
- **Overflow handling**: When roster caps are insufficient, affected players are surfaced in an overflow report with division context.
- **Diagnostics**: Algorithm emits a structured summary (team counts, buddy stats, overflow list) persisted to `scheduler_runs`.

### Test harness plan
- Use Jest with a fixture loader that seeds in-memory objects mirroring the schema (players, coaches, divisions, configuration).
- Provide scenario fixtures: balanced division, buddy-heavy division, coach overlap division, and capacity-deficit division.
- Assert both database mutations (mocked repositories) and diagnostic payload content for each scenario.
- Integrate snapshot tests for the overflow report and buddy resolution report to detect regressions in admin-facing outputs.

## Next Steps
- Implement Jest unit tests for buddy pairing logic, roster balancing, and overflow detection using the seed data proposed in the data modeling plan.
- Design admin UI wireframes for the roster review page, including filters and manual adjustment controls.
- Draft Supabase Row Level Security policies limiting roster edits to authenticated admin roles.
