-- Initial schema draft for youth sports scheduler
-- This file translates the data modeling plan into concrete SQL DDL
-- statements suitable for a Supabase/Postgres migration.  It focuses on
-- core entities required for registration intake, team formation, and
-- scheduling.  RLS policies will be defined in subsequent migrations.

begin;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'day_of_week') then
        create type day_of_week as enum ('mon','tue','wed','thu','fri','sat','sun');
    end if;
end$$;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'source_enum') then
        create type source_enum as enum ('auto','manual');
    end if;
end$$;

create or replace function trigger_set_timestamp()
returns trigger
language plpgsql
set search_path = public
as $$
begin
    new.updated_at = timezone('utc', now());
    return new;
end;
$$;

create table if not exists season_settings (
    id            bigint generated by default as identity primary key,
    season_label  text        not null,
    season_year   integer     not null,
    season_start  date        not null,
    season_end    date        not null,
    roster_formula jsonb      not null default '{}'::jsonb,
    daylight_adjustments jsonb not null default '[]'::jsonb,
    exports_config jsonb      not null default '{}'::jsonb,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    unique (season_label, season_year)
);

do $$
begin
    if not exists (select 1 from pg_type where typname = 'gender_policy_enum') then
        create type gender_policy_enum as enum ('coed', 'girls', 'boys');
    end if;
end$$;

create table if not exists divisions (
    id              uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    name            text not null,
    gender_policy   gender_policy_enum not null default 'coed',
    max_roster_size smallint not null,
    play_format     text not null,
    season_start    date not null,
    season_end      date not null,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (season_settings_id, name)
);

create table if not exists players (
    id                        uuid primary key default gen_random_uuid(),
    division_id               uuid not null references divisions(id) on delete cascade,
    external_registration_id  text not null,
    first_name                text not null,
    last_name                 text not null,
    preferred_name            text,
    date_of_birth             date,
    grade                     text,
    guardian_contacts         jsonb not null default '[]'::jsonb,
    mutual_buddy_code         text,
    skill_tier                text check (skill_tier in ('novice', 'developing', 'advanced')),
    coach_volunteer           boolean not null default false,
    notes                     text,
    created_at                timestamptz not null default timezone('utc', now()),
    updated_at                timestamptz not null default timezone('utc', now()),
    unique (division_id, external_registration_id)
);

create index if not exists players_mutual_buddy_code_idx
    on players (mutual_buddy_code)
    where mutual_buddy_code is not null;

create table if not exists coaches (
    id                           uuid primary key default gen_random_uuid(),
    user_id                      uuid references auth.users(id) on delete set null,
    player_id                    uuid references players(id) on delete set null,
    full_name                    text not null,
    email                        text not null check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    phone                        text,
    certifications               text,
    preferred_practice_days      day_of_week[] check (preferred_practice_days <@ array['mon','tue','wed','thu']::day_of_week[]),
    preferred_practice_window    tsrange,
    can_coach_multiple_teams     boolean not null default false,
    status                       text not null default 'active' check (status in ('active', 'pending-confirmation', 'inactive')),
    created_at                   timestamptz not null default timezone('utc', now()),
    updated_at                   timestamptz not null default timezone('utc', now()),
    unique (email),
    unique (user_id)
);

create table if not exists locations (
    id                  uuid primary key default gen_random_uuid(),
    name                text not null,
    address             text,
    lighting_available  boolean not null default false,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (name)
);

create table if not exists fields (
    id              uuid primary key default gen_random_uuid(),
    location_id     uuid not null references locations(id) on delete cascade,
    name            text not null,
    surface_type    text,
    supports_halves boolean not null default false,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (location_id, name)
);

create table if not exists field_subunits (
    id         uuid primary key default gen_random_uuid(),
    field_id   uuid not null references fields(id) on delete cascade,
    label      text not null,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique (field_id, label)
);

create table if not exists practice_slots (
    id                uuid primary key default gen_random_uuid(),
    field_id          uuid not null references fields(id) on delete cascade,
    field_subunit_id  uuid references field_subunits(id) on delete cascade,
    day_of_week       day_of_week not null check (day_of_week in ('mon','tue','wed','thu')),
    start_time        time not null,
    end_time          time not null,
    capacity          smallint not null default 1,
    valid_from        date not null,
    valid_until       date not null,
    created_at        timestamptz not null default timezone('utc', now()),
    updated_at        timestamptz not null default timezone('utc', now()),
    constraint practice_slots_time_check check (end_time > start_time)
);

create index if not exists practice_slots_lookup_idx
    on practice_slots (day_of_week, start_time);

create unique index if not exists practice_slots_subunit_unique_idx
    on practice_slots (field_subunit_id, day_of_week, start_time, valid_from)
    where field_subunit_id is not null;

create unique index if not exists practice_slots_field_unique_idx
    on practice_slots (field_id, day_of_week, start_time, valid_from)
    where field_subunit_id is null;

create table if not exists game_slots (
    id            uuid primary key default gen_random_uuid(),
    field_id      uuid not null references fields(id) on delete cascade,
    division_id   uuid references divisions(id) on delete set null,
    slot_date     date not null,
    start_time    time not null,
    end_time      time not null,
    week_index    smallint,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    constraint game_slots_time_check check (end_time > start_time),
    unique (field_id, slot_date, start_time)
);

create table if not exists teams (
    id                   uuid primary key default gen_random_uuid(),
    division_id          uuid not null references divisions(id) on delete cascade,
    name                 text not null,
    coach_id             uuid references coaches(id) on delete set null,
    assistant_coach_ids  uuid[] default '{}'::uuid[],
    practice_slot_id     uuid references practice_slots(id) on delete set null,
    notes                text,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    unique (division_id, name)
);

create table if not exists team_players (
    team_id   uuid not null references teams(id) on delete cascade,
    player_id uuid not null references players(id) on delete cascade,
    role      text not null default 'player',
    source    source_enum not null default 'auto'::source_enum,
    added_at  timestamptz not null default timezone('utc', now()),
    primary key (team_id, player_id)
);

create table if not exists practice_assignments (
    id                  uuid primary key default gen_random_uuid(),
    team_id             uuid not null references teams(id) on delete cascade,
    practice_slot_id    uuid not null references practice_slots(id) on delete cascade,
    effective_date_range daterange not null,
    source              source_enum not null default 'auto'::source_enum,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    constraint practice_assignments_effective_date_range_not_empty check (not isempty(effective_date_range)),
    unique (team_id, practice_slot_id, effective_date_range)
);

create table if not exists games (
    id              uuid primary key default gen_random_uuid(),
    game_slot_id    uuid not null unique references game_slots(id) on delete cascade,
    home_team_id    uuid not null references teams(id) on delete cascade,
    away_team_id    uuid not null references teams(id) on delete cascade,
    week_index      smallint,
    score_home      smallint,
    score_away      smallint,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    constraint games_team_difference check (home_team_id <> away_team_id)
);

create or replace function ensure_assistant_coach_ids_valid()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    duplicates uuid[];
    missing_coaches uuid[];
begin
    if new.assistant_coach_ids is null or cardinality(new.assistant_coach_ids) = 0 then
        return new;
    end if;

    if array_position(new.assistant_coach_ids, null) is not null then
        raise exception 'assistant_coach_ids cannot contain null values';
    end if;

    select array_agg(coach_id)
      into duplicates
    from (
        select coach_id
        from unnest(new.assistant_coach_ids) as coach_id
        group by coach_id
        having count(*) > 1
    ) dup;

    if duplicates is not null then
        raise exception 'assistant_coach_ids contains duplicate values: %', duplicates;
    end if;

    if new.coach_id is not null and new.coach_id = any(new.assistant_coach_ids) then
        raise exception 'Head coach % cannot also be listed as an assistant', new.coach_id;
    end if;

    select array_agg(u.coach_id)
      into missing_coaches
    from unnest(new.assistant_coach_ids) as u(coach_id)
    left join coaches c on c.id = u.coach_id
    where c.id is null;

    if missing_coaches is not null then
        raise exception 'assistant_coach_ids references coaches that do not exist: %', missing_coaches;
    end if;

    return new;
end;
$$;

create or replace function ensure_game_team_consistency()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    home_division uuid;
    away_division uuid;
begin
    select division_id into home_division from teams where id = new.home_team_id;
    if home_division is null then
        raise exception 'Home team % does not exist', new.home_team_id;
    end if;

    select division_id into away_division from teams where id = new.away_team_id;
    if away_division is null then
        raise exception 'Away team % does not exist', new.away_team_id;
    end if;

    if home_division <> away_division then
        raise exception 'Teams % and % belong to different divisions', new.home_team_id, new.away_team_id;
    end if;

    if new.game_slot_id is not null then
        perform 1
        from game_slots gs
        where gs.id = new.game_slot_id
          and (gs.division_id is null or gs.division_id = home_division);

        if not found then
            raise exception 'Game slot % is not compatible with division %', new.game_slot_id, home_division;
        end if;
    end if;

    return new;
end;
$$;



drop trigger if exists ensure_teams_assistant_coaches_valid on teams;
create trigger ensure_teams_assistant_coaches_valid
    before insert or update on teams
    for each row execute function ensure_assistant_coach_ids_valid();



drop trigger if exists ensure_games_valid on games;
create trigger ensure_games_valid
    before insert or update on games
    for each row execute function ensure_game_team_consistency();



create table if not exists import_jobs (
    id                 uuid primary key default gen_random_uuid(),
    job_type           text not null check (job_type in ('registration','fields','manual')),
    storage_path       text not null,
    status             text not null check (status in ('queued','processing','completed','completed_with_warnings','needs_fix')),
    started_at         timestamptz default timezone('utc', now()),
    completed_at       timestamptz,
    total_rows         integer,
    processed_rows     integer,
    error_summary      jsonb default '{}'::jsonb,
    warning_summary    jsonb default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    created_at         timestamptz not null default timezone('utc', now())
);

create table if not exists staging_players (
    id                    bigint generated by default as identity primary key,
    import_job_id         uuid not null references import_jobs(id) on delete cascade,
    raw_payload           jsonb not null,
    normalized_payload    jsonb,
    validation_errors     jsonb default '[]'::jsonb,
    validation_warnings   jsonb default '[]'::jsonb,
    processed_at          timestamptz,
    created_at            timestamptz not null default timezone('utc', now())
);

create table if not exists player_buddies (
    player_id        uuid not null references players(id) on delete cascade,
    buddy_player_id  uuid not null references players(id) on delete cascade,
    source_import_job uuid not null references import_jobs(id) on delete cascade,
    is_mutual        boolean not null default false,
    created_at       timestamptz not null default timezone('utc', now()),
    primary key (player_id, buddy_player_id),
    constraint player_buddies_player_ne_buddy check (player_id <> buddy_player_id)
);

create table if not exists scheduler_runs (
    id                 uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    run_type           text not null check (run_type in ('team','practice','game')),
    status             text not null check (status in ('queued','running','completed','completed_with_warnings','needs_manual_review','failed')),
    parameters         jsonb not null default '{}'::jsonb,
    metrics            jsonb not null default '{}'::jsonb,
    results            jsonb not null default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    started_at         timestamptz,
    completed_at       timestamptz,
    created_at         timestamptz not null default timezone('utc', now()),
    updated_at         timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_runs (
    id                   uuid primary key default gen_random_uuid(),
    scheduler_run_type   text not null check (scheduler_run_type in ('team','practice','game','composite')),
    scheduler_run_id     uuid references scheduler_runs(id) on delete set null,
    season_settings_id   bigint references season_settings(id) on delete set null,
    status               text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    findings_severity    text check (findings_severity in ('none','warnings','errors')),
    metrics_summary      jsonb not null default '{}'::jsonb,
    input_snapshot       jsonb not null default '{}'::jsonb,
    auto_fix_summary     jsonb not null default '{}'::jsonb,
    created_by           uuid references auth.users(id) on delete set null,
    started_at           timestamptz,
    completed_at         timestamptz,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    constraint evaluation_runs_scheduler_presence check (
        scheduler_run_type = 'composite' or scheduler_run_id is not null
    )
);

create table if not exists evaluation_findings (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    severity          text not null check (severity in ('error','warning','info')),
    finding_code      text not null,
    description       text not null,
    affected_entities jsonb not null default '[]'::jsonb,
    auto_fix_applied  boolean not null default false,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_metrics (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    metric_key        text not null,
    metric_value      numeric,
    thresholds        jsonb not null default '{}'::jsonb,
    created_at        timestamptz not null default timezone('utc', now()),
    unique (evaluation_run_id, metric_key)
);

create table if not exists evaluation_run_events (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    event_type        text not null check (event_type in ('auto_fix','manual_override','note')),
    event_payload     jsonb not null,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists export_jobs (
    id             uuid primary key default gen_random_uuid(),
    season_settings_id bigint references season_settings(id) on delete set null,
    job_type       text not null check (job_type in ('master','team')),
    status         text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    payload        jsonb not null default '{}'::jsonb,
    storage_path   text,
    schema_version text not null default 'v1',
    error_details  jsonb not null default '{}'::jsonb,
    created_by     uuid references auth.users(id) on delete set null,
    started_at     timestamptz,
    completed_at   timestamptz,
    created_at     timestamptz not null default timezone('utc', now()),
    updated_at     timestamptz not null default timezone('utc', now())
);

create table if not exists email_log (
    id             bigint generated by default as identity primary key,
    export_job_id  uuid references export_jobs(id) on delete set null,
    recipient_email text not null check (recipient_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    action         text not null check (action in ('draft_generated','copied','sent')),
    metadata       jsonb not null default '{}'::jsonb,
    created_at     timestamptz not null default timezone('utc', now())
);

do $$
declare
    t_name text;
begin
    foreach t_name in array ['scheduler_runs', 'evaluation_runs', 'export_jobs']
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

do $$
declare
    t_name text;
begin
    foreach t_name in array [
        'season_settings', 'divisions', 'players', 'coaches', 'locations',
        'fields', 'field_subunits', 'practice_slots', 'game_slots', 'teams',
        'practice_assignments', 'games'
    ]
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

commit;
