-- Initial schema draft for youth sports scheduler
-- This file translates the data modeling plan into concrete SQL DDL
-- statements suitable for a Supabase/Postgres migration.  It focuses on
-- core entities required for registration intake, team formation, and
-- scheduling.  RLS policies will be defined in subsequent migrations.

begin;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'day_of_week') then
        create type day_of_week as enum ('mon','tue','wed','thu','fri','sat','sun');
    end if;
end$$;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'source_enum') then
        create type source_enum as enum ('auto','manual');
    end if;
end$$;

create or replace function trigger_set_timestamp()
returns trigger
language plpgsql
set search_path = public
as $$
begin
    new.updated_at = timezone('utc', now());
    return new;
end;
$$;

create table if not exists season_settings (
    id            bigint generated by default as identity primary key,
    season_label  text        not null,
    season_year   integer     not null,
    season_start  date        not null,
    season_end    date        not null,
    roster_formula jsonb      not null default '{}'::jsonb,
    daylight_adjustments jsonb not null default '[]'::jsonb,
    exports_config jsonb      not null default '{}'::jsonb,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    unique (season_label, season_year)
);

do $$
begin
    if not exists (select 1 from pg_type where typname = 'gender_policy_enum') then
        create type gender_policy_enum as enum ('coed', 'girls', 'boys');
    end if;
end$$;

create table if not exists divisions (
    id              uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    name            text not null,
    gender_policy   gender_policy_enum not null default 'coed',
    max_roster_size smallint not null,
    play_format     text not null,
    season_start    date not null,
    season_end      date not null,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (season_settings_id, name)
);

create table if not exists players (
    id                        uuid primary key default gen_random_uuid(),
    division_id               uuid not null references divisions(id) on delete cascade,
    external_registration_id  text not null,
    first_name                text not null,
    last_name                 text not null,
    preferred_name            text,
    date_of_birth             date,
    grade                     text,
    guardian_contacts         jsonb not null default '[]'::jsonb,
    mutual_buddy_code         text,
    skill_tier                text check (skill_tier in ('novice', 'developing', 'advanced')),
    coach_volunteer           boolean not null default false,
    notes                     text,
    created_at                timestamptz not null default timezone('utc', now()),
    updated_at                timestamptz not null default timezone('utc', now()),
    unique (division_id, external_registration_id)
);

create index if not exists players_mutual_buddy_code_idx
    on players (mutual_buddy_code)
    where mutual_buddy_code is not null;

create table if not exists coaches (
    id                           uuid primary key default gen_random_uuid(),
    user_id                      uuid references auth.users(id) on delete set null,
    player_id                    uuid references players(id) on delete set null,
    full_name                    text not null,
    email                        text not null check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    phone                        text,
    certifications               text,
    preferred_practice_days      day_of_week[] check (preferred_practice_days <@ array['mon','tue','wed','thu']::day_of_week[]),
    preferred_practice_window    tsrange,
    can_coach_multiple_teams     boolean not null default false,
    status                       text not null default 'active' check (status in ('active', 'pending-confirmation', 'inactive')),
    created_at                   timestamptz not null default timezone('utc', now()),
    updated_at                   timestamptz not null default timezone('utc', now()),
    unique (email),
    unique (user_id)
);

create table if not exists locations (
    id                  uuid primary key default gen_random_uuid(),
    name                text not null,
    address             text,
    lighting_available  boolean not null default false,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (name)
);

create table if not exists fields (
    id              uuid primary key default gen_random_uuid(),
    location_id     uuid not null references locations(id) on delete cascade,
    name            text not null,
    surface_type    text,
    supports_halves boolean not null default false,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (location_id, name)
);

create table if not exists field_subunits (
    id         uuid primary key default gen_random_uuid(),
    field_id   uuid not null references fields(id) on delete cascade,
    label      text not null,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique (field_id, label)
);

create table if not exists practice_slots (
    id                uuid primary key default gen_random_uuid(),
    field_id          uuid not null references fields(id) on delete cascade,
    field_subunit_id  uuid references field_subunits(id) on delete cascade,
    day_of_week       day_of_week not null check (day_of_week in ('mon','tue','wed','thu')),
    start_time        time not null,
    end_time          time not null,
    capacity          smallint not null default 1,
    valid_from        date not null,
    valid_until       date not null,
    created_at        timestamptz not null default timezone('utc', now()),
    updated_at        timestamptz not null default timezone('utc', now()),
    constraint practice_slots_time_check check (end_time > start_time)
);

create index if not exists practice_slots_lookup_idx
    on practice_slots (day_of_week, start_time);

create unique index if not exists practice_slots_subunit_unique_idx
    on practice_slots (field_subunit_id, day_of_week, start_time, valid_from)
    where field_subunit_id is not null;

create unique index if not exists practice_slots_field_unique_idx
    on practice_slots (field_id, day_of_week, start_time, valid_from)
    where field_subunit_id is null;

create table if not exists game_slots (
    id            uuid primary key default gen_random_uuid(),
    field_id      uuid not null references fields(id) on delete cascade,
    division_id   uuid references divisions(id) on delete set null,
    slot_date     date not null,
    start_time    time not null,
    end_time      time not null,
    week_index    smallint,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    constraint game_slots_time_check check (end_time > start_time),
    unique (field_id, slot_date, start_time)
);

create table if not exists teams (
    id                   uuid primary key default gen_random_uuid(),
    division_id          uuid not null references divisions(id) on delete cascade,
    name                 text not null,
    coach_id             uuid references coaches(id) on delete set null,
    assistant_coach_ids  uuid[] default '{}'::uuid[],
    practice_slot_id     uuid references practice_slots(id) on delete set null,
    notes                text,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    unique (division_id, name)
);

create table if not exists team_players (
    team_id   uuid not null references teams(id) on delete cascade,
    player_id uuid not null references players(id) on delete cascade,
    role      text not null default 'player',
    source    source_enum not null default 'auto'::source_enum,
    added_at  timestamptz not null default timezone('utc', now()),
    primary key (team_id, player_id)
);

create table if not exists practice_assignments (
    id                  uuid primary key default gen_random_uuid(),
    team_id             uuid not null references teams(id) on delete cascade,
    practice_slot_id    uuid not null references practice_slots(id) on delete cascade,
    effective_date_range daterange not null,
    source              source_enum not null default 'auto'::source_enum,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    constraint practice_assignments_effective_date_range_not_empty check (not isempty(effective_date_range)),
    unique (team_id, practice_slot_id, effective_date_range)
);

create table if not exists games (
    id              uuid primary key default gen_random_uuid(),
    game_slot_id    uuid not null unique references game_slots(id) on delete cascade,
    home_team_id    uuid not null references teams(id) on delete cascade,
    away_team_id    uuid not null references teams(id) on delete cascade,
    week_index      smallint,
    score_home      smallint,
    score_away      smallint,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    constraint games_team_difference check (home_team_id <> away_team_id)
);

create or replace function ensure_assistant_coach_ids_valid()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    duplicates uuid[];
    missing_coaches uuid[];
begin
    if new.assistant_coach_ids is null or cardinality(new.assistant_coach_ids) = 0 then
        return new;
    end if;

    if array_position(new.assistant_coach_ids, null) is not null then
        raise exception 'assistant_coach_ids cannot contain null values';
    end if;

    select array_agg(coach_id)
      into duplicates
    from (
        select coach_id
        from unnest(new.assistant_coach_ids) as coach_id
        group by coach_id
        having count(*) > 1
    ) dup;

    if duplicates is not null then
        raise exception 'assistant_coach_ids contains duplicate values: %', duplicates;
    end if;

    if new.coach_id is not null and new.coach_id = any(new.assistant_coach_ids) then
        raise exception 'Head coach % cannot also be listed as an assistant', new.coach_id;
    end if;

    select array_agg(u.coach_id)
      into missing_coaches
    from unnest(new.assistant_coach_ids) as u(coach_id)
    left join coaches c on c.id = u.coach_id
    where c.id is null;

    if missing_coaches is not null then
        raise exception 'assistant_coach_ids references coaches that do not exist: %', missing_coaches;
    end if;

    return new;
end;
$$;

create or replace function ensure_game_team_consistency()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    home_division uuid;
    away_division uuid;
begin
    select division_id into home_division from teams where id = new.home_team_id;
    if home_division is null then
        raise exception 'Home team % does not exist', new.home_team_id;
    end if;

    select division_id into away_division from teams where id = new.away_team_id;
    if away_division is null then
        raise exception 'Away team % does not exist', new.away_team_id;
    end if;

    if home_division <> away_division then
        raise exception 'Teams % and % belong to different divisions', new.home_team_id, new.away_team_id;
    end if;

    if new.game_slot_id is not null then
        perform 1
        from game_slots gs
        where gs.id = new.game_slot_id
          and (gs.division_id is null or gs.division_id = home_division);

        if not found then
            raise exception 'Game slot % is not compatible with division %', new.game_slot_id, home_division;
        end if;
    end if;

    return new;
end;
$$;



drop trigger if exists ensure_teams_assistant_coaches_valid on teams;
create trigger ensure_teams_assistant_coaches_valid
    before insert or update on teams
    for each row execute function ensure_assistant_coach_ids_valid();



drop trigger if exists ensure_games_valid on games;
create trigger ensure_games_valid
    before insert or update on games
    for each row execute function ensure_game_team_consistency();



create table if not exists import_jobs (
    id                 uuid primary key default gen_random_uuid(),
    job_type           text not null check (job_type in ('registration','fields','manual')),
    storage_path       text not null,
    status             text not null check (status in ('queued','processing','completed','completed_with_warnings','needs_fix')),
    started_at         timestamptz default timezone('utc', now()),
    completed_at       timestamptz,
    total_rows         integer,
    processed_rows     integer,
    error_summary      jsonb default '{}'::jsonb,
    warning_summary    jsonb default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    created_at         timestamptz not null default timezone('utc', now())
);

create table if not exists staging_players (
    id                    bigint generated by default as identity primary key,
    import_job_id         uuid not null references import_jobs(id) on delete cascade,
    raw_payload           jsonb not null,
    normalized_payload    jsonb,
    validation_errors     jsonb default '[]'::jsonb,
    validation_warnings   jsonb default '[]'::jsonb,
    processed_at          timestamptz,
    created_at            timestamptz not null default timezone('utc', now())
);

create table if not exists player_buddies (
    player_id        uuid not null references players(id) on delete cascade,
    buddy_player_id  uuid not null references players(id) on delete cascade,
    source_import_job uuid not null references import_jobs(id) on delete cascade,
    is_mutual        boolean not null default false,
    created_at       timestamptz not null default timezone('utc', now()),
    primary key (player_id, buddy_player_id),
    constraint player_buddies_player_ne_buddy check (player_id <> buddy_player_id)
);

create table if not exists scheduler_runs (
    id                 uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    run_type           text not null check (run_type in ('team','practice','game')),
    status             text not null check (status in ('queued','running','completed','completed_with_warnings','needs_manual_review','failed')),
    parameters         jsonb not null default '{}'::jsonb,
    metrics            jsonb not null default '{}'::jsonb,
    results            jsonb not null default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    started_at         timestamptz,
    completed_at       timestamptz,
    created_at         timestamptz not null default timezone('utc', now()),
    updated_at         timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_runs (
    id                   uuid primary key default gen_random_uuid(),
    scheduler_run_type   text not null check (scheduler_run_type in ('team','practice','game','composite')),
    scheduler_run_id     uuid references scheduler_runs(id) on delete set null,
    season_settings_id   bigint references season_settings(id) on delete set null,
    status               text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    findings_severity    text check (findings_severity in ('none','warnings','errors')),
    metrics_summary      jsonb not null default '{}'::jsonb,
    input_snapshot       jsonb not null default '{}'::jsonb,
    auto_fix_summary     jsonb not null default '{}'::jsonb,
    created_by           uuid references auth.users(id) on delete set null,
    started_at           timestamptz,
    completed_at         timestamptz,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    constraint evaluation_runs_scheduler_presence check (
        scheduler_run_type = 'composite' or scheduler_run_id is not null
    )
);

create table if not exists evaluation_findings (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    severity          text not null check (severity in ('error','warning','info')),
    finding_code      text not null,
    description       text not null,
    affected_entities jsonb not null default '[]'::jsonb,
    auto_fix_applied  boolean not null default false,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_metrics (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    metric_key        text not null,
    metric_value      numeric,
    thresholds        jsonb not null default '{}'::jsonb,
    created_at        timestamptz not null default timezone('utc', now()),
    unique (evaluation_run_id, metric_key)
);

create table if not exists evaluation_run_events (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    event_type        text not null check (event_type in ('auto_fix','manual_override','note')),
    event_payload     jsonb not null,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists export_jobs (
    id             uuid primary key default gen_random_uuid(),
    season_settings_id bigint references season_settings(id) on delete set null,
    job_type       text not null check (job_type in ('master','team')),
    status         text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    payload        jsonb not null default '{}'::jsonb,
    storage_path   text,
    schema_version text not null default 'v1',
    error_details  jsonb not null default '{}'::jsonb,
    created_by     uuid references auth.users(id) on delete set null,
    started_at     timestamptz,
    completed_at   timestamptz,
    created_at     timestamptz not null default timezone('utc', now()),
    updated_at     timestamptz not null default timezone('utc', now())
);

create table if not exists email_log (
    id             bigint generated by default as identity primary key,
    export_job_id  uuid references export_jobs(id) on delete set null,
    recipient_email text not null check (recipient_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    action         text not null check (action in ('draft_generated','copied','sent')),
    metadata       jsonb not null default '{}'::jsonb,
    created_at     timestamptz not null default timezone('utc', now())
);

do $$
declare
    t_name text;
begin
    foreach t_name in array ['scheduler_runs', 'evaluation_runs', 'export_jobs']
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

do $$
declare
    t_name text;
begin
    foreach t_name in array [
        'season_settings', 'divisions', 'players', 'coaches', 'locations',
        'fields', 'field_subunits', 'practice_slots', 'game_slots', 'teams',
        'practice_assignments', 'games'
    ]
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

-- ==========================================
-- RLS POLICIES
-- ==========================================

-- 1. Helper Functions
create or replace function public.current_user_role()
returns text
language sql
stable
as $$
  select nullif(current_setting('request.jwt.claim.role', true), '')::text;
$$;

create or replace view public.coach_team_map as
select
    c.user_id as coach_user_id,
    t.id as team_id
from coaches c
join teams t on t.coach_id = c.id
where c.user_id is not null
union
select
    c.user_id as coach_user_id,
    t.id as team_id
from coaches c
join teams t on c.id = any(t.assistant_coach_ids)
where c.user_id is not null;

-- 2. Enable RLS on all tables
alter table season_settings enable row level security;
alter table divisions enable row level security;
alter table players enable row level security;
alter table coaches enable row level security;
alter table locations enable row level security;
alter table fields enable row level security;
alter table field_subunits enable row level security;
alter table practice_slots enable row level security;
alter table game_slots enable row level security;
alter table teams enable row level security;
alter table team_players enable row level security;
alter table practice_assignments enable row level security;
alter table games enable row level security;
alter table import_jobs enable row level security;
alter table staging_players enable row level security;
alter table player_buddies enable row level security;
alter table scheduler_runs enable row level security;
alter table evaluation_runs enable row level security;
alter table evaluation_findings enable row level security;
alter table evaluation_metrics enable row level security;
alter table evaluation_run_events enable row level security;
alter table export_jobs enable row level security;
alter table email_log enable row level security;

-- 3. Create Admin Policies (Full Access)
-- Pattern: Allow ALL operations if the user has the 'admin' role.

-- season_settings
create policy "Admins can do everything on season_settings"
  on season_settings for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- divisions
create policy "Admins can do everything on divisions"
  on divisions for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- players
create policy "Admins can do everything on players"
  on players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

create policy "Coaches can view roster names (masked)"
  on players for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and exists (
      select 1
      from public.coach_team_map ctm
      join public.team_players tp on tp.team_id = ctm.team_id
      where tp.player_id = players.id
        and ctm.coach_user_id = auth.uid()
    )
  );

-- coaches
create policy "Admins can do everything on coaches"
  on coaches for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

create policy "Coaches can view own profile"
  on coaches for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  );

create policy "Coaches can update own profile"
  on coaches for update
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  )
  with check (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  );

-- locations
create policy "Admins can do everything on locations"
  on locations for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- fields
create policy "Admins can do everything on fields"
  on fields for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- field_subunits
create policy "Admins can do everything on field_subunits"
  on field_subunits for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- practice_slots
create policy "Admins can do everything on practice_slots"
  on practice_slots for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- game_slots
create policy "Admins can do everything on game_slots"
  on game_slots for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- teams
create policy "Admins can do everything on teams"
  on teams for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

create policy "Coaches can view their teams"
  on teams for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and exists (
      select 1
      from public.coach_team_map ctm
      where ctm.team_id = teams.id
        and ctm.coach_user_id = auth.uid()
    )
  );

-- team_players
create policy "Admins can do everything on team_players"
  on team_players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- practice_assignments
create policy "Admins can do everything on practice_assignments"
  on practice_assignments for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- games
create policy "Admins can do everything on games"
  on games for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- import_jobs
create policy "Admins can do everything on import_jobs"
  on import_jobs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- staging_players
create policy "Admins can do everything on staging_players"
  on staging_players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- player_buddies
create policy "Admins can do everything on player_buddies"
  on player_buddies for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- scheduler_runs
create policy "Admins can do everything on scheduler_runs"
  on scheduler_runs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_runs
create policy "Admins can do everything on evaluation_runs"
  on evaluation_runs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_findings
create policy "Admins can do everything on evaluation_findings"
  on evaluation_findings for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_metrics
create policy "Admins can do everything on evaluation_metrics"
  on evaluation_metrics for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_run_events
create policy "Admins can do everything on evaluation_run_events"
  on evaluation_run_events for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- export_jobs
create policy "Admins can do everything on export_jobs"
  on export_jobs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- email_log
create policy "Admins can do everything on email_log"
  on email_log for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- ==========================================
-- EVALUATION SCHEMA
-- ==========================================

-- Create table for storing schedule evaluations
create table if not exists schedule_evaluations (
    id uuid primary key default gen_random_uuid(),
    run_id text, -- Optional link to a scheduler run
    evaluation_type text not null check (evaluation_type in ('practice', 'game', 'combined')),
    status text not null check (status in ('ok', 'attention-needed', 'action-required')),
    summary jsonb not null default '{}'::jsonb, -- High-level metrics
    issues jsonb not null default '[]'::jsonb, -- Array of issue objects
    details jsonb not null default '{}'::jsonb, -- Full evaluation payload
    created_at timestamptz not null default timezone('utc', now()),
    created_by text -- Optional user identifier
);

-- Enable RLS
alter table schedule_evaluations enable row level security;

-- Policies
create policy "Admins can do everything on schedule_evaluations"
  on schedule_evaluations for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

create policy "Service role can do everything on schedule_evaluations"
  on schedule_evaluations for all
  to service_role
  using (true)
  with check (true);

-- Allow read-only access to authenticated users (e.g. coaches viewing status)
create policy "Authenticated users can view schedule_evaluations"
  on schedule_evaluations for select
  to authenticated
  using (true);

-- ==========================================
-- PERSISTENCE FUNCTIONS
-- ==========================================

-- Function to persist practice schedule transactionally
create or replace function persist_practice_schedule(
  run_data jsonb,
  assignments jsonb
)
returns void
language plpgsql
security invoker -- Run with the caller's permissions (RLS)
as $$
begin
  -- 1. Persist Scheduler Run
  if run_data is not null then
    insert into scheduler_runs (
      id,
      run_type,
      season_settings_id,
      status,
      parameters,
      metrics,
      results,
      created_by,
      started_at,
      completed_at,
      updated_at
    )
    values (
      (run_data->>'id')::text,
      (run_data->>'run_type')::text,
      (run_data->>'season_settings_id')::uuid,
      (run_data->>'status')::text,
      (run_data->'parameters'),
      (run_data->'metrics'),
      (run_data->'results'),
      (run_data->>'created_by')::text,
      (run_data->>'started_at')::timestamptz,
      (run_data->>'completed_at')::timestamptz,
      (run_data->>'updated_at')::timestamptz
    )
    on conflict (id) do update set
      status = excluded.status,
      parameters = excluded.parameters,
      metrics = excluded.metrics,
      results = excluded.results,
      completed_at = excluded.completed_at,
      updated_at = excluded.updated_at;
  end if;

  -- 2. Persist Assignments
  if assignments is not null and jsonb_array_length(assignments) > 0 then
    insert into practice_assignments (
      team_id,
      slot_id,
      run_id,
      start_time,
      end_time,
      field_id,
      created_at
    )
    select
      (item->>'team_id')::text,
      (item->>'slot_id')::text,
      (item->>'run_id')::text,
      (item->>'start_time')::timestamptz,
      (item->>'end_time')::timestamptz,
      (item->>'field_id')::text,
      now()
    from jsonb_array_elements(assignments) as item
    on conflict (team_id, slot_id) do update set
      run_id = excluded.run_id,
      start_time = excluded.start_time,
      end_time = excluded.end_time,
      field_id = excluded.field_id;
  end if;
end;
$$;

-- Function to persist game schedule transactionally
create or replace function persist_game_schedule(
  run_data jsonb,
  assignments jsonb
)
returns void
language plpgsql
security invoker -- Run with the caller's permissions (RLS)
as $$
begin
  -- 1. Persist Scheduler Run
  if run_data is not null then
    insert into scheduler_runs (
      id,
      run_type,
      season_settings_id,
      status,
      parameters,
      metrics,
      results,
      created_by,
      started_at,
      completed_at,
      updated_at
    )
    values (
      (run_data->>'id')::text,
      (run_data->>'run_type')::text,
      (run_data->>'season_settings_id')::uuid,
      (run_data->>'status')::text,
      (run_data->'parameters'),
      (run_data->'metrics'),
      (run_data->'results'),
      (run_data->>'created_by')::text,
      (run_data->>'started_at')::timestamptz,
      (run_data->>'completed_at')::timestamptz,
      (run_data->>'updated_at')::timestamptz
    )
    on conflict (id) do update set
      status = excluded.status,
      parameters = excluded.parameters,
      metrics = excluded.metrics,
      results = excluded.results,
      completed_at = excluded.completed_at,
      updated_at = excluded.updated_at;
  end if;

  -- 2. Persist Assignments
  if assignments is not null and jsonb_array_length(assignments) > 0 then
    insert into game_assignments (
      division,
      week_index,
      slot_id,
      start,
      end,
      field_id,
      home_team_id,
      away_team_id,
      run_id
    )
    select
      (item->>'division')::text,
      (item->>'week_index')::int,
      (item->>'slot_id')::text,
      (item->>'start')::timestamptz,
      (item->>'end')::timestamptz,
      (item->>'field_id')::text,
      (item->>'home_team_id')::text,
      (item->>'away_team_id')::text,
      (item->>'run_id')::text
    from jsonb_array_elements(assignments) as item
    on conflict (slot_id, field_id) do update set -- Assuming composite key or similar constraint
      division = excluded.division,
      week_index = excluded.week_index,
      start = excluded.start,
      end = excluded.end,
      home_team_id = excluded.home_team_id,
      away_team_id = excluded.away_team_id,
      run_id = excluded.run_id;
  end if;
end;
$$;

commit;
