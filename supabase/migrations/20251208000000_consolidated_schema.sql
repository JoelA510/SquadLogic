-- Consolidated Schema Migration
-- Combines initial schema, storage setup, RPCs, and new tables.

-- ==========================================
-- 1. INITIAL SCHEMA
-- ==========================================

begin;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'day_of_week') then
        create type day_of_week as enum ('mon','tue','wed','thu','fri','sat','sun');
    end if;
end$$;

do $$
begin
    if not exists (select 1 from pg_type where typname = 'source_enum') then
        create type source_enum as enum ('auto','manual');
    end if;
end$$;

create or replace function trigger_set_timestamp()
returns trigger
language plpgsql
set search_path = public
as $$
begin
    new.updated_at = timezone('utc', now());
    return new;
end;
$$;

create table if not exists season_settings (
    id            bigint generated by default as identity primary key,
    season_label  text        not null,
    season_year   integer     not null,
    season_start  date        not null,
    season_end    date        not null,
    roster_formula jsonb      not null default '{}'::jsonb,
    daylight_adjustments jsonb not null default '[]'::jsonb,
    exports_config jsonb      not null default '{}'::jsonb,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    unique (season_label, season_year)
);

do $$
begin
    if not exists (select 1 from pg_type where typname = 'gender_policy_enum') then
        create type gender_policy_enum as enum ('coed', 'girls', 'boys');
    end if;
end$$;

create table if not exists divisions (
    id              uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    name            text not null,
    gender_policy   gender_policy_enum not null default 'coed',
    max_roster_size smallint not null,
    play_format     text not null,
    season_start    date not null,
    season_end      date not null,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (season_settings_id, name)
);

create table if not exists players (
    id                        uuid primary key default gen_random_uuid(),
    division_id               uuid not null references divisions(id) on delete cascade,
    external_registration_id  text not null,
    first_name                text not null,
    last_name                 text not null,
    preferred_name            text,
    date_of_birth             date,
    grade                     text,
    guardian_contacts         jsonb not null default '[]'::jsonb,
    mutual_buddy_code         text,
    skill_tier                text check (skill_tier in ('novice', 'developing', 'advanced')),
    coach_volunteer           boolean not null default false,
    notes                     text,
    created_at                timestamptz not null default timezone('utc', now()),
    updated_at                timestamptz not null default timezone('utc', now()),
    unique (division_id, external_registration_id)
);

create index if not exists players_mutual_buddy_code_idx
    on players (mutual_buddy_code)
    where mutual_buddy_code is not null;

create table if not exists coaches (
    id                           uuid primary key default gen_random_uuid(),
    user_id                      uuid references auth.users(id) on delete set null,
    player_id                    uuid references players(id) on delete set null,
    full_name                    text not null,
    email                        text not null check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    phone                        text,
    certifications               text,
    preferred_practice_days      day_of_week[] check (preferred_practice_days <@ array['mon','tue','wed','thu']::day_of_week[]),
    preferred_practice_window    tsrange,
    can_coach_multiple_teams     boolean not null default false,
    status                       text not null default 'active' check (status in ('active', 'pending-confirmation', 'inactive')),
    created_at                   timestamptz not null default timezone('utc', now()),
    updated_at                   timestamptz not null default timezone('utc', now()),
    unique (email),
    unique (user_id)
);

create table if not exists locations (
    id                  uuid primary key default gen_random_uuid(),
    name                text not null,
    address             text,
    lighting_available  boolean not null default false,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    unique (name)
);

create table if not exists fields (
    id              uuid primary key default gen_random_uuid(),
    location_id     uuid not null references locations(id) on delete cascade,
    name            text not null,
    surface_type    text,
    supports_halves boolean not null default false,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    unique (location_id, name)
);

create table if not exists field_subunits (
    id         uuid primary key default gen_random_uuid(),
    field_id   uuid not null references fields(id) on delete cascade,
    label      text not null,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique (field_id, label)
);

create table if not exists practice_slots (
    id                uuid primary key default gen_random_uuid(),
    field_id          uuid not null references fields(id) on delete cascade,
    field_subunit_id  uuid references field_subunits(id) on delete cascade,
    day_of_week       day_of_week not null check (day_of_week in ('mon','tue','wed','thu')),
    start_time        time not null,
    end_time          time not null,
    capacity          smallint not null default 1,
    valid_from        date not null,
    valid_until       date not null,
    created_at        timestamptz not null default timezone('utc', now()),
    updated_at        timestamptz not null default timezone('utc', now()),
    constraint practice_slots_time_check check (end_time > start_time)
);

create index if not exists practice_slots_lookup_idx
    on practice_slots (day_of_week, start_time);

create unique index if not exists practice_slots_subunit_unique_idx
    on practice_slots (field_subunit_id, day_of_week, start_time, valid_from)
    where field_subunit_id is not null;

create unique index if not exists practice_slots_field_unique_idx
    on practice_slots (field_id, day_of_week, start_time, valid_from)
    where field_subunit_id is null;

create table if not exists game_slots (
    id            uuid primary key default gen_random_uuid(),
    field_id      uuid not null references fields(id) on delete cascade,
    division_id   uuid references divisions(id) on delete set null,
    slot_date     date not null,
    start_time    time not null,
    end_time      time not null,
    week_index    smallint,
    created_at    timestamptz not null default timezone('utc', now()),
    updated_at    timestamptz not null default timezone('utc', now()),
    constraint game_slots_time_check check (end_time > start_time),
    unique (field_id, slot_date, start_time)
);

create table if not exists teams (
    id                   uuid primary key default gen_random_uuid(),
    division_id          uuid not null references divisions(id) on delete cascade,
    name                 text not null,
    coach_id             uuid references coaches(id) on delete set null,
    assistant_coach_ids  uuid[] default '{}'::uuid[],
    practice_slot_id     uuid references practice_slots(id) on delete set null,
    notes                text,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    unique (division_id, name)
);

create table if not exists team_players (
    team_id   uuid not null references teams(id) on delete cascade,
    player_id uuid not null references players(id) on delete cascade,
    role      text not null default 'player',
    source    source_enum not null default 'auto'::source_enum,
    added_at  timestamptz not null default timezone('utc', now()),
    primary key (team_id, player_id)
);

create table if not exists practice_assignments (
    id                  uuid primary key default gen_random_uuid(),
    team_id             uuid not null references teams(id) on delete cascade,
    practice_slot_id    uuid not null references practice_slots(id) on delete cascade,
    effective_date_range daterange not null,
    source              source_enum not null default 'auto'::source_enum,
    created_at          timestamptz not null default timezone('utc', now()),
    updated_at          timestamptz not null default timezone('utc', now()),
    constraint practice_assignments_effective_date_range_not_empty check (not isempty(effective_date_range)),
    unique (team_id, practice_slot_id, effective_date_range)
);

create table if not exists games (
    id              uuid primary key default gen_random_uuid(),
    game_slot_id    uuid not null unique references game_slots(id) on delete cascade,
    home_team_id    uuid not null references teams(id) on delete cascade,
    away_team_id    uuid not null references teams(id) on delete cascade,
    week_index      smallint,
    score_home      smallint,
    score_away      smallint,
    created_at      timestamptz not null default timezone('utc', now()),
    updated_at      timestamptz not null default timezone('utc', now()),
    constraint games_team_difference check (home_team_id <> away_team_id)
);

create or replace function ensure_assistant_coach_ids_valid()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    duplicates uuid[];
    missing_coaches uuid[];
begin
    if new.assistant_coach_ids is null or cardinality(new.assistant_coach_ids) = 0 then
        return new;
    end if;

    if array_position(new.assistant_coach_ids, null) is not null then
        raise exception 'assistant_coach_ids cannot contain null values';
    end if;

    select array_agg(coach_id)
      into duplicates
    from (
        select coach_id
        from unnest(new.assistant_coach_ids) as coach_id
        group by coach_id
        having count(*) > 1
    ) dup;

    if duplicates is not null then
        raise exception 'assistant_coach_ids contains duplicate values: %', duplicates;
    end if;

    if new.coach_id is not null and new.coach_id = any(new.assistant_coach_ids) then
        raise exception 'Head coach % cannot also be listed as an assistant', new.coach_id;
    end if;

    select array_agg(u.coach_id)
      into missing_coaches
    from unnest(new.assistant_coach_ids) as u(coach_id)
    left join coaches c on c.id = u.coach_id
    where c.id is null;

    if missing_coaches is not null then
        raise exception 'assistant_coach_ids references coaches that do not exist: %', missing_coaches;
    end if;

    return new;
end;
$$;

create or replace function ensure_game_team_consistency()
returns trigger
language plpgsql
set search_path = public
as $$
declare
    home_division uuid;
    away_division uuid;
begin
    select division_id into home_division from teams where id = new.home_team_id;
    if home_division is null then
        raise exception 'Home team % does not exist', new.home_team_id;
    end if;

    select division_id into away_division from teams where id = new.away_team_id;
    if away_division is null then
        raise exception 'Away team % does not exist', new.away_team_id;
    end if;

    if home_division <> away_division then
        raise exception 'Teams % and % belong to different divisions', new.home_team_id, new.away_team_id;
    end if;

    if new.game_slot_id is not null then
        perform 1
        from game_slots gs
        where gs.id = new.game_slot_id
          and (gs.division_id is null or gs.division_id = home_division);

        if not found then
            raise exception 'Game slot % is not compatible with division %', new.game_slot_id, home_division;
        end if;
    end if;

    return new;
end;
$$;



drop trigger if exists ensure_teams_assistant_coaches_valid on teams;
create trigger ensure_teams_assistant_coaches_valid
    before insert or update on teams
    for each row execute function ensure_assistant_coach_ids_valid();



drop trigger if exists ensure_games_valid on games;
create trigger ensure_games_valid
    before insert or update on games
    for each row execute function ensure_game_team_consistency();



create table if not exists import_jobs (
    id                 uuid primary key default gen_random_uuid(),
    job_type           text not null check (job_type in ('registration','fields','manual')),
    storage_path       text not null,
    status             text not null check (status in ('queued','processing','completed','completed_with_warnings','needs_fix')),
    started_at         timestamptz default timezone('utc', now()),
    completed_at       timestamptz,
    total_rows         integer,
    processed_rows     integer,
    error_summary      jsonb default '{}'::jsonb,
    warning_summary    jsonb default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    created_at         timestamptz not null default timezone('utc', now())
);

create table if not exists staging_players (
    id                    bigint generated by default as identity primary key,
    import_job_id         uuid not null references import_jobs(id) on delete cascade,
    raw_payload           jsonb not null,
    normalized_payload    jsonb,
    validation_errors     jsonb default '[]'::jsonb,
    validation_warnings   jsonb default '[]'::jsonb,
    processed_at          timestamptz,
    created_at            timestamptz not null default timezone('utc', now())
);

create table if not exists player_buddies (
    player_id        uuid not null references players(id) on delete cascade,
    buddy_player_id  uuid not null references players(id) on delete cascade,
    source_import_job uuid not null references import_jobs(id) on delete cascade,
    is_mutual        boolean not null default false,
    created_at       timestamptz not null default timezone('utc', now()),
    primary key (player_id, buddy_player_id),
    constraint player_buddies_player_ne_buddy check (player_id <> buddy_player_id)
);

create table if not exists scheduler_runs (
    id                 uuid primary key default gen_random_uuid(),
    season_settings_id bigint not null references season_settings(id) on delete cascade,
    run_type           text not null check (run_type in ('team','practice','game')),
    status             text not null check (status in ('queued','running','completed','completed_with_warnings','needs_manual_review','failed')),
    parameters         jsonb not null default '{}'::jsonb,
    metrics            jsonb not null default '{}'::jsonb,
    results            jsonb not null default '{}'::jsonb,
    created_by         uuid references auth.users(id) on delete set null,
    started_at         timestamptz,
    completed_at       timestamptz,
    created_at         timestamptz not null default timezone('utc', now()),
    updated_at         timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_runs (
    id                   uuid primary key default gen_random_uuid(),
    scheduler_run_type   text not null check (scheduler_run_type in ('team','practice','game','composite')),
    scheduler_run_id     uuid references scheduler_runs(id) on delete set null,
    season_settings_id   bigint references season_settings(id) on delete set null,
    status               text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    findings_severity    text check (findings_severity in ('none','warnings','errors')),
    metrics_summary      jsonb not null default '{}'::jsonb,
    input_snapshot       jsonb not null default '{}'::jsonb,
    auto_fix_summary     jsonb not null default '{}'::jsonb,
    created_by           uuid references auth.users(id) on delete set null,
    started_at           timestamptz,
    completed_at         timestamptz,
    created_at           timestamptz not null default timezone('utc', now()),
    updated_at           timestamptz not null default timezone('utc', now()),
    constraint evaluation_runs_scheduler_presence check (
        scheduler_run_type = 'composite' or scheduler_run_id is not null
    )
);

create table if not exists evaluation_findings (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    severity          text not null check (severity in ('error','warning','info')),
    finding_code      text not null,
    description       text not null,
    affected_entities jsonb not null default '[]'::jsonb,
    auto_fix_applied  boolean not null default false,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists evaluation_metrics (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    metric_key        text not null,
    metric_value      numeric,
    thresholds        jsonb not null default '{}'::jsonb,
    created_at        timestamptz not null default timezone('utc', now()),
    unique (evaluation_run_id, metric_key)
);

create table if not exists evaluation_run_events (
    id                bigint generated by default as identity primary key,
    evaluation_run_id uuid not null references evaluation_runs(id) on delete cascade,
    event_type        text not null check (event_type in ('auto_fix','manual_override','note')),
    event_payload     jsonb not null,
    created_at        timestamptz not null default timezone('utc', now())
);

create table if not exists export_jobs (
    id             uuid primary key default gen_random_uuid(),
    season_settings_id bigint references season_settings(id) on delete set null,
    job_type       text not null check (job_type in ('master','team')),
    status         text not null check (status in ('queued','running','completed','completed_with_warnings','failed')),
    payload        jsonb not null default '{}'::jsonb,
    storage_path   text,
    schema_version text not null default 'v1',
    error_details  jsonb not null default '{}'::jsonb,
    created_by     uuid references auth.users(id) on delete set null,
    started_at     timestamptz,
    completed_at   timestamptz,
    created_at     timestamptz not null default timezone('utc', now()),
    updated_at     timestamptz not null default timezone('utc', now())
);

create table if not exists email_log (
    id             bigint generated by default as identity primary key,
    export_job_id  uuid references export_jobs(id) on delete set null,
    recipient_email text not null check (recipient_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    action         text not null check (action in ('draft_generated','copied','sent')),
    metadata       jsonb not null default '{}'::jsonb,
    created_at     timestamptz not null default timezone('utc', now())
);

do $$
declare
    t_name text;
begin
    for t_name in select unnest(array['scheduler_runs', 'evaluation_runs', 'export_jobs'])
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

do $$
declare
    t_name text;
begin
    for t_name in select unnest(array[
        'season_settings', 'divisions', 'players', 'coaches', 'locations',
        'fields', 'field_subunits', 'practice_slots', 'game_slots', 'teams',
        'practice_assignments', 'games'
    ])
    loop
        execute format('drop trigger if exists %I on %I', 'set_timestamp_' || t_name, t_name);
        execute format(
            'create trigger %I before update on %I for each row execute function trigger_set_timestamp()',
            'set_timestamp_' || t_name,
            t_name
        );
    end loop;
end$$;

-- ==========================================
-- RLS POLICIES
-- ==========================================

-- 1. Helper Functions
create or replace function public.current_user_role()
returns text
language sql
stable
as $$
  select nullif(current_setting('request.jwt.claim.role', true), '')::text;
$$;

create or replace view public.coach_team_map as
select
    c.user_id as coach_user_id,
    t.id as team_id
from coaches c
join teams t on t.coach_id = c.id
where c.user_id is not null
union
select
    c.user_id as coach_user_id,
    t.id as team_id
from coaches c
join teams t on c.id = any(t.assistant_coach_ids)
where c.user_id is not null;

-- 2. Enable RLS on all tables
alter table season_settings enable row level security;
alter table divisions enable row level security;
alter table players enable row level security;
alter table coaches enable row level security;
alter table locations enable row level security;
alter table fields enable row level security;
alter table field_subunits enable row level security;
alter table practice_slots enable row level security;
alter table game_slots enable row level security;
alter table teams enable row level security;
alter table team_players enable row level security;
alter table practice_assignments enable row level security;
alter table games enable row level security;
alter table import_jobs enable row level security;
alter table staging_players enable row level security;
alter table player_buddies enable row level security;
alter table scheduler_runs enable row level security;
alter table evaluation_runs enable row level security;
alter table evaluation_findings enable row level security;
alter table evaluation_metrics enable row level security;
alter table evaluation_run_events enable row level security;
alter table export_jobs enable row level security;
alter table email_log enable row level security;

-- 3. Create Admin Policies (Full Access)
-- Pattern: Allow ALL operations if the user has the 'admin' role.

-- season_settings
drop policy if exists "Admins can do everything on season_settings" on season_settings;
create policy "Admins can do everything on season_settings"
  on season_settings for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- divisions
drop policy if exists "Admins can do everything on divisions" on divisions;
create policy "Admins can do everything on divisions"
  on divisions for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- players
drop policy if exists "Admins can do everything on players" on players;
create policy "Admins can do everything on players"
  on players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

drop policy if exists "Coaches can view roster names (masked)" on players;
create policy "Coaches can view roster names (masked)"
  on players for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and exists (
      select 1
      from public.coach_team_map ctm
      join public.team_players tp on tp.team_id = ctm.team_id
      where tp.player_id = players.id
      and ctm.coach_user_id = auth.uid()
    )
  );

-- coaches
drop policy if exists "Admins can do everything on coaches" on coaches;
create policy "Admins can do everything on coaches"
  on coaches for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

drop policy if exists "Coaches can view own profile" on coaches;
create policy "Coaches can view own profile"
  on coaches for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  );

drop policy if exists "Coaches can update own profile" on coaches;
create policy "Coaches can update own profile"
  on coaches for update
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  )
  with check (
    (auth.jwt() ->> 'role') = 'coach'
    and user_id = auth.uid()
  );

-- locations
drop policy if exists "Admins can do everything on locations" on locations;
create policy "Admins can do everything on locations"
  on locations for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- fields
drop policy if exists "Admins can do everything on fields" on fields;
create policy "Admins can do everything on fields"
  on fields for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- field_subunits
drop policy if exists "Admins can do everything on field_subunits" on field_subunits;
create policy "Admins can do everything on field_subunits"
  on field_subunits for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- practice_slots
drop policy if exists "Admins can do everything on practice_slots" on practice_slots;
create policy "Admins can do everything on practice_slots"
  on practice_slots for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- game_slots
drop policy if exists "Admins can do everything on game_slots" on game_slots;
create policy "Admins can do everything on game_slots"
  on game_slots for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- teams
drop policy if exists "Admins can do everything on teams" on teams;
create policy "Admins can do everything on teams"
  on teams for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

drop policy if exists "Coaches can view their teams" on teams;
create policy "Coaches can view their teams"
  on teams for select
  to authenticated
  using (
    (auth.jwt() ->> 'role') = 'coach'
    and exists (
      select 1
      from public.coach_team_map ctm
      where ctm.team_id = teams.id
        and ctm.coach_user_id = auth.uid()
    )
  );

-- team_players
drop policy if exists "Admins can do everything on team_players" on team_players;
create policy "Admins can do everything on team_players"
  on team_players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- practice_assignments
drop policy if exists "Admins can do everything on practice_assignments" on practice_assignments;
create policy "Admins can do everything on practice_assignments"
  on practice_assignments for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- games
drop policy if exists "Admins can do everything on games" on games;
create policy "Admins can do everything on games"
  on games for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- import_jobs
drop policy if exists "Admins can do everything on import_jobs" on import_jobs;
create policy "Admins can do everything on import_jobs"
  on import_jobs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- staging_players
drop policy if exists "Admins can do everything on staging_players" on staging_players;
create policy "Admins can do everything on staging_players"
  on staging_players for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- player_buddies
drop policy if exists "Admins can do everything on player_buddies" on player_buddies;
create policy "Admins can do everything on player_buddies"
  on player_buddies for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- scheduler_runs
-- UPDATED POLICY: Allow authenticated users to manage runs
drop policy if exists "Authenticated users can manage scheduler_runs" on scheduler_runs;
create policy "Authenticated users can manage scheduler_runs"
  on scheduler_runs for all
  to authenticated
  using (true)
  with check (true);

-- evaluation_runs
drop policy if exists "Admins can do everything on evaluation_runs" on evaluation_runs;
create policy "Admins can do everything on evaluation_runs"
  on evaluation_runs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_findings
drop policy if exists "Admins can do everything on evaluation_findings" on evaluation_findings;
create policy "Admins can do everything on evaluation_findings"
  on evaluation_findings for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_metrics
drop policy if exists "Admins can do everything on evaluation_metrics" on evaluation_metrics;
create policy "Admins can do everything on evaluation_metrics"
  on evaluation_metrics for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- evaluation_run_events
drop policy if exists "Admins can do everything on evaluation_run_events" on evaluation_run_events;
create policy "Admins can do everything on evaluation_run_events"
  on evaluation_run_events for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- export_jobs
drop policy if exists "Admins can do everything on export_jobs" on export_jobs;
create policy "Admins can do everything on export_jobs"
  on export_jobs for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- email_log
drop policy if exists "Admins can do everything on email_log" on email_log;
create policy "Admins can do everything on email_log"
  on email_log for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

-- ==========================================
-- EVALUATION SCHEMA
-- ==========================================

-- Create table for storing schedule evaluations
create table if not exists schedule_evaluations (
    id uuid primary key default gen_random_uuid(),
    run_id text, -- Optional link to a scheduler run
    evaluation_type text not null check (evaluation_type in ('practice', 'game', 'combined')),
    status text not null check (status in ('ok', 'attention-needed', 'action-required')),
    summary jsonb not null default '{}'::jsonb, -- High-level metrics
    issues jsonb not null default '[]'::jsonb, -- Array of issue objects
    details jsonb not null default '{}'::jsonb, -- Full evaluation payload
    created_at timestamptz not null default timezone('utc', now()),
    created_by uuid references auth.users(id) on delete set null -- Optional user identifier
);

-- Enable RLS
alter table schedule_evaluations enable row level security;

-- Policies
drop policy if exists "Admins can do everything on schedule_evaluations" on schedule_evaluations;
create policy "Admins can do everything on schedule_evaluations"
  on schedule_evaluations for all
  to authenticated
  using ((auth.jwt() ->> 'role') = 'admin')
  with check ((auth.jwt() ->> 'role') = 'admin');

drop policy if exists "Service role can do everything on schedule_evaluations" on schedule_evaluations;
create policy "Service role can do everything on schedule_evaluations"
  on schedule_evaluations for all
  to service_role
  using (true)
  with check (true);

-- Allow read-only access to authenticated users (e.g. coaches viewing status)
drop policy if exists "Authenticated users can view schedule_evaluations" on schedule_evaluations;
create policy "Authenticated users can view schedule_evaluations"
  on schedule_evaluations for select
  to authenticated
  using (true);

-- ==========================================
-- PERSISTENCE FUNCTIONS
-- ==========================================

-- Function to persist practice schedule transactionally
create or replace function persist_practice_schedule(
  run_data jsonb,
  assignments jsonb
)
returns void
language plpgsql
security invoker
as $$
declare
  v_run_id uuid;
  v_assignment jsonb;
begin
  -- 1. Upsert Scheduler Run
  insert into scheduler_runs (
    id,
    season_settings_id,
    run_type,
    status,
    parameters,
    metrics,
    results,
    started_at,
    completed_at,
    created_by
  )
  select
    (run_data->>'id')::uuid,
    (run_data->>'season_settings_id')::bigint,
    run_data->>'run_type',
    run_data->>'status',
    run_data->'parameters',
    run_data->'metrics',
    run_data->'results',
    (run_data->>'started_at')::timestamptz,
    (run_data->>'completed_at')::timestamptz,
    (run_data->>'created_by')::uuid
  on conflict (id) do update set
    status = excluded.status,
    results = excluded.results,
    completed_at = excluded.completed_at;

  v_run_id := (run_data->>'id')::uuid;

  -- 2. Upsert Practice Assignments
  -- Note: We assume the frontend passes valid team_id and practice_slot_id
  if jsonb_array_length(assignments) > 0 then
    for v_assignment in select * from jsonb_array_elements(assignments)
    loop
      insert into practice_assignments (
        team_id,
        practice_slot_id,
        effective_date_range,
        source
      )
      values (
        (v_assignment->>'team_id')::uuid,
        (v_assignment->>'practice_slot_id')::uuid,
        (v_assignment->>'effective_date_range')::daterange,
        coalesce((v_assignment->>'source'), 'auto')::source_enum
      )
      on conflict (team_id, practice_slot_id, effective_date_range) do update set
        source = excluded.source;
    end loop;
  end if;
end;
$$;

commit;

-- ==========================================
-- 2. STORAGE BUCKET
-- ==========================================

-- Create the raw-imports bucket if it doesn't exist
insert into storage.buckets (id, name, public)
values ('raw-imports', 'raw-imports', true)
on conflict (id) do nothing;

-- Set up RLS policies for the bucket
-- Note: Policies might fail if they already exist, so we drop them first just in case
drop policy if exists "Public Access" on storage.objects;
drop policy if exists "Public Access" on storage;
create policy "Public Access"
  on storage.objects for select
  using ( bucket_id = 'raw-imports' );

drop policy if exists "Authenticated Upload" on storage.objects;
drop policy if exists "Authenticated Upload" on storage;
create policy "Authenticated Upload"
  on storage.objects for insert
  with check ( bucket_id = 'raw-imports' and auth.role() = 'authenticated' );


-- ==========================================
-- 3. TEAM PERSISTENCE RPC
-- ==========================================

CREATE OR REPLACE FUNCTION persist_team_schedule(
    run_data jsonb,
    teams jsonb,
    team_players jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY INVOKER
AS $$
DECLARE
    v_run_id uuid;
    v_teams_count int;
    v_players_count int;
BEGIN
    -- 1. Persist Scheduler Run
    INSERT INTO scheduler_runs (
        id,
        season_settings_id,
        run_type,
        status,
        parameters,
        metrics,
        results,
        started_at,
        completed_at,
        created_by
    )
    SELECT
        (run_data->>'id')::uuid,
        (run_data->>'season_settings_id')::bigint,
        run_data->>'run_type',
        run_data->>'status',
        run_data->'parameters',
        run_data->'metrics',
        run_data->'results',
        (run_data->>'started_at')::timestamptz,
        (run_data->>'completed_at')::timestamptz,
        (run_data->>'created_by')::uuid
    ON CONFLICT (id) DO UPDATE SET
        status = EXCLUDED.status,
        results = EXCLUDED.results,
        completed_at = EXCLUDED.completed_at;

    v_run_id := (run_data->>'id')::uuid;

    -- 2. Upsert Teams
    IF jsonb_array_length(teams) > 0 THEN
        INSERT INTO teams (
            id,
            division_id,
            coach_id,
            name
        )
        SELECT
            t->>'id',
            t->>'division_id',
            t->>'coach_id',
            t->>'name'
        FROM jsonb_array_elements(teams) t
        ON CONFLICT (id) DO UPDATE SET
            division_id = EXCLUDED.division_id,
            coach_id = EXCLUDED.coach_id,
            name = EXCLUDED.name;
            
        GET DIAGNOSTICS v_teams_count = ROW_COUNT;
    ELSE
        v_teams_count := 0;
    END IF;

    -- 3. Upsert Team Players
    IF jsonb_array_length(team_players) > 0 THEN
        INSERT INTO team_players (
            team_id,
            player_id,
            role,
            source
        )
        SELECT
            (tp->>'team_id')::uuid,
            (tp->>'player_id')::uuid,
            COALESCE(tp->>'role', 'player'),
            COALESCE(tp->>'source', 'auto')::source_enum
        FROM jsonb_array_elements(team_players) tp
        ON CONFLICT (team_id, player_id) DO UPDATE SET
            role = EXCLUDED.role,
            source = EXCLUDED.source;

        GET DIAGNOSTICS v_players_count = ROW_COUNT;
    ELSE
        v_players_count := 0;
    END IF;

    RETURN jsonb_build_object(
        'status', 'success',
        'run_id', v_run_id,
        'updated_teams', v_teams_count,
        'updated_players', v_players_count
    );
END;
$$;


-- ==========================================
-- 4. IMPORTS TABLE
-- ==========================================

-- Create imports table to store parsed CSV data
create table if not exists imports (
    id uuid primary key default gen_random_uuid(),
    user_id uuid references auth.users(id) on delete cascade,
    file_name text not null,
    import_type text not null check (import_type in ('players', 'coaches', 'fields')),
    data jsonb not null,
    created_at timestamptz not null default timezone('utc', now())
);

-- Enable RLS
alter table imports enable row level security;

-- Policies
drop policy if exists "Users can insert their own imports" on imports;
drop policy if exists "Users can insert their own imports" on imports;
create policy "Users can insert their own imports"
    on imports for insert
    to authenticated
    with check (auth.uid() = user_id);

drop policy if exists "Users can view their own imports" on imports;
drop policy if exists "Users can view their own imports" on imports;
create policy "Users can view their own imports"
    on imports for select
    to authenticated
    using (auth.uid() = user_id);

drop policy if exists "Users can delete their own imports" on imports;
drop policy if exists "Users can delete their own imports" on imports;
create policy "Users can delete their own imports"
    on imports for delete
    to authenticated
    using (auth.uid() = user_id);
